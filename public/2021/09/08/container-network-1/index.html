<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/yteng.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/yteng.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/yteng.jpg">
  <link rel="mask-icon" href="/images/yteng.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="容器已经成为托管大规模分布式应用程序的实际方法，容器覆盖网络对于为容器提供可移植性至关重要，但它们在吞吐量、延迟和CPU使用方面造成了巨大的开销。     参考： https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;nsdi19&#x2F;presentation&#x2F;zhuo">
<meta name="keywords" content="Container">
<meta property="og:type" content="article">
<meta property="og:title" content="Slim-对低开销容器覆盖网络的操作系统内核支持">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;index.html">
<meta property="og:site_name" content="萧逸小杨的个人博客">
<meta property="og:description" content="容器已经成为托管大规模分布式应用程序的实际方法，容器覆盖网络对于为容器提供可移植性至关重要，但它们在吞吐量、延迟和CPU使用方面造成了巨大的开销。     参考： https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;nsdi19&#x2F;presentation&#x2F;zhuo">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210908224057340.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210911163653609.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210911172050383.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210911175905043.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210911222817374.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210911224328375.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210911225923727.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912112119544.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912131404119.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912132623212.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912133258237.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912152756280.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912152957785.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912153548295.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912153824855.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912154159822.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912154235036.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210912154957014.png">
<meta property="og:updated_time" content="2021-09-22T12:42:08.427Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;09&#x2F;08&#x2F;container-network-1&#x2F;image-20210908224057340.png">

<link rel="canonical" href="http://yoursite.com/2021/09/08/container-network-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Slim-对低开销容器覆盖网络的操作系统内核支持 | 萧逸小杨的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">萧逸小杨的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">个人成长&技术学习</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/08/container-network-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yteng.jpg">
      <meta itemprop="name" content="萧逸小杨">
      <meta itemprop="description" content="不断学习、不断更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧逸小杨的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Slim-对低开销容器覆盖网络的操作系统内核支持
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-08 21:49:34" itemprop="dateCreated datePublished" datetime="2021-09-08T21:49:34+08:00">2021-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-22 20:42:08" itemprop="dateModified" datetime="2021-09-22T20:42:08+08:00">2021-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn/" itemprop="url" rel="index">
                    <span itemprop="name">Learn</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/08/container-network-1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/08/container-network-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <center>
    容器已经成为托管大规模分布式应用程序的实际方法，容器覆盖网络对于为容器提供可移植性至关重要，但它们在吞吐量、延迟和CPU使用方面造成了巨大的开销。
    参考： https://www.usenix.org/conference/nsdi19/presentation/zhuo
</center>

<a id="more"></a>



<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>容器已经成为托管大规模分布式应用程序的实际方法。容器覆盖网络对于为容器提供可移植性至关重要，但它们在吞吐量、延迟和CPU使用方面造成了巨大的开销。关键问题是依赖于数据包转换来实现网络虚拟化。因此，每个数据包必须在发送方和接收方的主机操作系统内核中同时遍历该网络堆栈两次。我们设计并实现了Slim，这是一个低开销的容器覆盖网络，通过操作连接级元数据（<em>connection-level metadata</em>）来实现网络虚拟化。我们的解决方案与今天的容器化应用程序保持兼容性。评估结果表明，Slim将内存中key-value存储 Memcached的吞吐量（throughput）提高了71%，同时减少了42%的延迟（latency）。Slim将内存中key-value存储的CPU使用降低了56%。Slim还可以将web服务器 Nginx的CPU使用降低22%-24%，将数据库服务器 PostgreSQL降低22%，将流处理框架Apache Kafka 的降低10%。</p>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>容器已经迅速成为管理和部署大规模分布式应用程序的实际方法，包括内存中的key-value存储、web服务器、数据库和数据处理框架。容器很有吸引力，因为它们又轻又便携。单台物理机器可以轻松托管标准虚拟机十倍以上的容器，从而节省大量成本。</p>
<p>Container overlay networks——为分布式容器应用程序提供可移植性的关键组件——允许一组容器使用自己独立的IP地址和端口号进行通信，无论它们分配在哪里或其他容器放置在同一个物理机器上。overlay network消除了在应用程序开发人员之间协调端口和IP地址的负担，并大大简化了将遗留的企业应用程序向云计算的迁移。今天，容器编排器，如DockerSwarm，需要使用overlay network来托管容器化的应用程序。</p>
<p><img src="/2021/09/08/container-network-1/image-20210908224057340.png" alt="image-20210908224057340"></p>
<p><strong>a图</strong>是今天的容器overlay network，b图是虚拟机的overlay network</p>
<p>然而，容器覆盖网络会带来巨大的开销。我们的基准测试（benchmark）显示，与主机网络连接相比，覆盖网络连接的吞吐量（throughput）降低了23-48%，包级延迟（latency）提高了34-85%，CPU使用（ CPU utilization）提高了93%。已知的优化技术（例如，数据包转向和对虚拟化的硬件支持）仅部分解决了这些问题。</p>
<p>关键问题是，今天的容器overlay network依赖于操作系统中的多个数据包转换来实现网络虚拟化（图a），这意味着每个数据包必须遍历两次网络堆栈，并且在发送端和接收端都有一个虚拟交换机。以发送一个数据包为例。容器应用程序发送的包首先遍历虚拟网络接口上的覆盖网络堆栈。然后，包穿越一个虚拟交换机进行包转换（例如，添加主机网络头）。最后，数据包遍历主机网络堆栈，并在主机网络接口上发送出去。在接收服务器上，这些图层以相反的顺序重复。</p>
<p>这种设计在很大程度上类似于虚拟机的覆盖网络(图1b)。由于虚拟机有自己的网络堆栈，管理程序必须发送/接收无需网络连接的原始覆盖数据报文，而不需要网络连接的上下文。但是，对于容器，操作系统内核对每个网络连接都有充分的交互。</p>
<p>在本文中，我们问我们是否可以设计和实现一个容器覆盖网络，在那里数据包通过操作系统内核的网络堆栈只有一次。这要求我们从覆盖网络的数据平面上删除数据包转换。我们通过在connection setup时操作连接级元数据、节省CPU周期和减少数据包延迟来实现网络虚拟化。</p>
<p>实现这样一个容器覆盖网络具有挑战性，因为：（1)网络虚拟化必须与今天未修改的容器应用程序兼容；(2)我们需要支持今天容器覆盖网络在数据平面上执行的相同网络策略；(3）我们需要保证与今天容器覆盖网络相同的安全模型。</p>
<p>我们设计并实现了Slim，这是一个低开销的容器覆盖网络，通过操作连接级元数据来提供网络虚拟化。我们的评估表明，与基于包转换的良好容器覆盖网络相比，Slim将key-value存储内存缓存的吞吐量（throughput）提高了71%，延迟（latency）减少了42%。Slim将内存缓存的CPU使用（CPU utilization）降低了56%。Slim还将Web服务器Nginx的CPU使用降低了22%-24%；数据库服务器PostgreSQL的降低了22%；而流处理框架Apache Kafka的则降低了10%。但是，Slim增加了connection setup的复杂性，导致connection setup时间延长了106%。Slim的其他限制：Slim支持静态容器迁移，但不支持容器实时迁移；基于连接的网络策略，但不支持基于数据包的网络策略；以及TCP，默认为UDP套接字的标准处理。</p>
<p>本文的贡献如下：</p>
<ul>
<li>使用几种数据平面优化对现有的容器覆盖网络进行基准（benchmark）测试。我们确定包处理成本（例如，包转换、网络栈的额外遍历）是当今容器覆盖网络的主要瓶颈。</li>
<li>Slim的设计和实现，这是一种操作连接级元数据以实现网络虚拟化的解决方案。Slim兼容今天的容器化应用程序和标准操作系统内核。Slim支持各种网络策略，并保证与当今的容器覆盖网络相同的安全模型。</li>
<li>演示了Slim对各种流行的容器化应用程序的好处，包括key-value存储、web服务器、数据库服务器和流处理框架。</li>
</ul>
<p>从根本上说，Slim将高效的虚拟化集成到操作系统内核的网络堆栈中。现代操作系统内核已经有效地支持虚拟化文件系统（使用挂载名称空间）和其他操作系统组件（例如，进程id、用户组）。网络堆栈是高效容器虚拟化的剩余性能差距。Slim 补充了这个差距。</p>
<p><img src="/2021/09/08/container-network-1/image-20210911163653609.png" alt="image-20210911163653609"></p>
<h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2 背景"></a>2 背景</h3><p>我们首先描述了传统的容器覆盖网络的体系结构，以及为什么它们对容器化的应用程序有用。然后，我们从吞吐量、延迟和CPU使用来量化今天的容器覆盖网络解决方案的开销。最后，我们证明了即使在应用已知的开销降低技术（例如，包转向）之后，开销也是显著的。</p>
<h4 id="2-1-Container-Overlay-Network"><a href="#2-1-Container-Overlay-Network" class="headerlink" title="2.1 Container Overlay Network"></a>2.1 Container Overlay Network</h4><p>容器通常有四种通信选项：bridge模式、host模式、macvlan模式和overlay模式。bridge模式仅用于在同一主机上通信的容器。使用桥接模式时，每个容器都有一个独立的IP地址。操作系统内核在不同容器之间转发流量。</p>
<p>我们如何启用不同主机上的容器之间的通信？在host模式下，容器直接使用其主机网络接口的IP地址。主机模式的网络性能接近直接使用主机操作系统网络栈的进程的性能。但是，主机模式会带来许多管理和部署挑战。首先，容器不能配置它们自己的IP地址；它们必须使用主机网络接口的IP地址。这使得移植变得复杂：分布式应用程序必须重写（re-writen）以发现和使用主机IP地址，如果容器可以迁移（例如，在检查点之后），应用程序必须能够适应其IP地址的动态变化。更糟糕的是，由于同一主机上的所有容器都共享相同的主机IP地址，因此只有一个容器可以绑定到给定的端口.(比如端口80)。从而导致在同一主机上运行的不同应用程序之间的协调复杂。事实上，由于这些问题，容器编排器，kubernetes，不允许使用主机模式。</p>
<p>Macvlan模式或类似的硬件机制(例如，SRIOV)允许容器具有不同于其主机的自己的IP地址。Macvlan或SR-IOV允许物理网卡模拟多个NIC与不同的MAC地址和IP地址，Macvlan通过使容器IP在主机网络上可路由，将主机网络扩展到容器中。然而，这种方法从根本上讲使数据中心网络路由复杂化。假设一个IP地址为IP1.2.3.[1-10]的分布式应用程序。[1-10]不共同位于同一主机，或者启动时在同一主机，但是一些容器被迁移。然后，主机的IP地址将不会是连续的。例如，一个容器可能在主机5.6.7.8上，而另一个容器可能在主机9.10.11.12上。Macvlan要求云提供商更改其核心网络路由，以重定向到IP1.2.3[1-10]的流量到5.6.7.8和9.10.11.12，可能需要为在数据中心中运行的数百万个容器中的每个容器提供一个单独的路由表条目。另一个限制是，容器必须选择与任何其他容器（或主机）的IP地址不重叠的IP地址。由于这些复杂的问题，今天，大多数云提供商都阻止了macvlan模式。</p>
<p>为了避免干扰主机网络上的路由，流行的选择是使用overlay模式。这是虚拟机的模拟，但对于一组容器——每个应用程序都有自己的网络名称空间，对其他容器或主机网络所做的选择没有影响或可见性。每个容器创建一个虚拟网络接口（由应用程序选择的IP地址）。虚拟网络接口通过操作系统内核内的虚拟交换机连接到外部（例如：在操作系统内核中的OpenvSwich)。当在主机网络上路由时，覆盖数据包用主机网络报头封装。这使得容器覆盖网络具有自己的IP地址空间和与主机网络脱节的网络配置；每个网络都可以完全独立地管理。今天有许多容器覆盖网络解决方案——如Weave、Falnnel和Docker Overlay[8]——所有这些都共享类似的内部架构）</p>
<p><img src="/2021/09/08/container-network-1/image-20210911172050383.png" alt="image-20210911172050383"></p>
<p>图2介绍了使用包转换实现网络虚拟化的容器覆盖网络的高级系统图，它显示了一个操作系统内核和一个由名称空间和cgroups构建的容器。命名空间隔离可以阻止容器化的应用程序访问主机网络接口。cgroups允许细粒度地控制容器内的应用程序可以消耗的资源总量(例如，CPU、内存和网络)</p>
<p>容器覆盖网络的关键组件是内核内部的一个虚拟交换机。虚拟交换机有两个主要功能：（1)网络桥接，允许同一主机上的容器进行通信，和(2）网络隧道，使覆盖流量能够通过物理网络传输。虚拟交换机通常使用开放的vxlan内核模块[42]进行配置，并以VXLAN作为隧道协议。</p>
<p>为了执行各种网络策略（例如，访问控制、速率限制和服务质量（qos）），网络运营商或容器协调器会对虚拟网络接口或虚拟交换机发布策略更新。例如，防火墙规则通常通过iptables实现，速率限制和服务质量(QoS)也可以在开放的vSwitch内核模块中配置。这些规则通常根据应用程序的虚拟IP地址指定，而不是主机的IP地址，这些IP地址可能会根据分配容器的位置而更改。</p>
<p>在覆盖网络中运行一组容器的主机必须在主机之间保持一致的全局网络视图（例如，虚拟到物理的IP映射）。他们通常使用外部的、容错的分布式数据存储或传播协议来实现这一点。</p>
<h4 id="2-2-容器覆盖网络中的开销"><a href="#2-2-容器覆盖网络中的开销" class="headerlink" title="2.2 容器覆盖网络中的开销"></a>2.2 容器覆盖网络中的开销</h4><p>今天的容器覆盖网络的开销来自于操作系统内核内的每个数据包处理（例如，数据包转换、网络堆栈的额外遍历）。</p>
<h5 id="2-2-1-一个覆盖的网络包的路径"><a href="#2-2-1-一个覆盖的网络包的路径" class="headerlink" title="2.2.1 一个覆盖的网络包的路径"></a>2.2.1 一个覆盖的网络包的路径</h5><p>在我们的示例（图2）中，假设之前已经在10.0.0.1和10.0.0.2之间建立了一个TCP连接。现在，该容器通过此连接向一个数据包发送到10.0.0.2。容器操作系统内核的覆盖网络堆栈首先在包头上写入虚拟目标IP地址10.0.0.2和源IP地址10.0.0.1。操作系统内核还编写包的以太网头，使包成为适当的以太网框架。以太网帧遍历一个虚拟以太网链路到主机内核的虚拟交换机的输入缓冲区。</p>
<p>虚拟交换机将以太网帧内的IP地址10.0.0.2识别为远程主机上的容器的IP地址。它使用其路由表中的主机源和目标地址向以太网帧添加一个物理IP报头。该包现在有物理头和虚拟头。在主机网络上，该包只是一个UDP包(假设隧道协议是VXLAN)，它的UDP有效负载是以太网帧。然后，操作系统内核使用主机网络堆栈将封装的数据包转发出去。</p>
<p>接收端的pipeline是相同的，除了虚拟交换机删除了主机网络报头，而不是添加一个。接收端从发送端的虚拟网络接口接收完全相同的以太网帧。</p>
<p>因此，我们可以看到为什么overlay network 开销是昂贵的：在覆盖网络上交付一个包需要一个额外的网络堆栈遍历，也需要包封装和拆包。</p>
<p><img src="/2021/09/08/container-network-1/image-20210911175905043.png" alt="image-20210911175905043"></p>
<p><strong>表2</strong>：与使用主机模式相比，容器覆盖网络上的单个TCP连接的吞吐量（Throughput）和延迟（RTT:一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值）。Intra-host是同一台物理机器上的连接；Inter-host44是通过40Gbps链路的两个不同物理机器之间的连接。±后面的数字表示标准差。括号内的数字显示了与使用主机模式相比的相对差值。</p>
<h5 id="2-2-2-定量开销"><a href="#2-2-2-定量开销" class="headerlink" title="2.2.2 定量开销"></a>2.2.2 定量开销</h5><p>我们给出了一个流行的容器覆盖网络实现Weave中的开销。我们的测试台由两台配备IntelXeonE5-2680的机器组成(12个物理核，2.5GHz)。这些机器使用超线程，因此每台机器都有24个虚拟核。每台机器运行Linux4.4版本，并有一个40Gbps的IntelXL710网卡。这两台机器通过一个40Gbps的链路直接连接。物理网卡被配置为使用接收侧缩放(RSS)。在我们所有的实验中，我们都没有改变物理nic的配置。</p>
<p>我们使用Weave的快速数据平面模式创建了一个覆盖网络（类似于图2中的架构）。我们使用iperf3创建一个单一的TCP连接，并研究容器覆盖网络上的TCP吞吐量。我们使用NPtcp来测量包级延迟。为了进行比较，我们还使用主机模式容器网络执行相同的测试。在我们所有的实验中，我们保持CPU在最大的时钟频率(使用IntelP-State驱动程序。</p>
<p>容器覆盖网络的开销非常显著。我们比较了四种不同设置下的TCP流吞吐量和数据包级延迟。表2显示了在10秒间隔内具有最大以太网帧大小的平均TCP流量吞吐量，以及针对10次测试的32字节TCP数据包的往返延迟。对于同一主机上的两个容器，TCP吞吐量减少了23%，延迟增加了34%。对于跨物理机器的容器，TCP吞吐量减少了近一半（48%），延迟增加了85%。由于不需要包封装，同一个物理机内容器覆盖网络降低了包封装。</p>
<p>为了理解主要瓶颈的来源，我们使用一个标准的Linux内核CPU预归档工具，mpstat来衡量CPU的使用。我们专门检查了在两个不同的物理机器上的覆盖网络。我们将TCP连接的速度设置为10Gbps，然后使用mpstat来确定10个测试中CPU周期花在哪里，每个测试持续10秒。表3显示了总体CPU使用和分类。与使用直接主机连接相比，在默认模式下（随机IRQ负载均衡），覆盖网络使CPU使用（相对来说）提高了93%。RPS（(receive packet steering接收包转向）和RFS（receive flow steering接收流转向）是我们对Weave进行的两个优化。</p>
<p><img src="/2021/09/08/container-network-1/image-20210911222817374.png" alt="image-20210911222817374"></p>
<p><strong>图3</strong> 不同覆盖网络设置下的CPU使用，通过单个用于10GbPsTCP连接的虚拟核心的数量来衡量。CPU周期被花费：在用户级应用程序(usr)、内核内部，但不包括中断处理(sys)和服务软件中断（软）。误差条表示标准差。</p>
<p>覆盖网络的主要CPU开销来自于服务软件中断；在默认的覆盖设置中，它对应于0.56个虚拟核。额外的CPU使用在软件中断处理类别中的原因是，数据包转换和额外的网络堆栈的遍历与系统调用没有直接关联。这些任务被卸载到每核专用软件线程。相比之下，使用主机模式，只有0.21个虚拟核心用于服务软件中断。这种CPU使用的差异捕获了遍历网络堆栈一次额外时间和数据包转换时所浪费的额外CPU周期。注意，我们没有分离CPU使用主要来自虚拟交换机还是额外的网络堆栈遍历。我们的解决方案Slim同时从容器覆盖网络数据平面上删除了这虚拟交换机和网络堆栈遍历这两个组件，因此了解这两个组件总共消耗了多少CPU利用率就足够了。</p>
<p>在2.3中，我们展示了现有的技术（例如，数据包转向）可以解决容器覆盖网络的一些性能问题。然而，仍然有大量的开销。</p>
<h4 id="2-3-已知技术调整数据面"><a href="#2-3-已知技术调整数据面" class="headerlink" title="2.3 已知技术调整数据面"></a>2.3 已知技术调整数据面</h4><p>有几种已知的技术可以减少数据平面的开销，数据包转向为网络接口创建多个队列，每个队列，并使用一致的散列将数据包映射到不同的队列。通过这种方式，同一网络连接中的数据包只在单个核上进行处理。因此，不同的核心不必访问相同的队列，从而消除了由于多核同步而造成的开销（例如缓存线冲突，锁）。表3显示了对使用数据包转向的容器覆盖网络上的吞吐量和延迟的变化。.</p>
<p><img src="/2021/09/08/container-network-1/image-20210911224328375.png" alt="image-20210911224328375"></p>
<p><strong>表3</strong> 针对跨两个物理主机的容器覆盖网络上的TCP吞吐量（Throughput）和延迟（<em>latency</em>）（32字节TCP数据包的往返时间RTT）。±后面的数字表示标准差。括号中的数字显示了与使用主机模式相比的相对差值。Random LB：随机的负载均衡 ，RPS：(receive packet steering接收包转向），RFS：（receive flow steering接收流转向） Host：主机模式</p>
<p>包转向将TCP吞吐量提高到使用主机TCP连接的91%以内，但它并没有降低包级别的延迟。我们尝试了两种分组转向选项，接收包转向(RPS)和接收流转向(RFS)，用于覆盖网络中的内部虚拟网络接口。RPS确保同一流中的数据包总是命中相同的核心。RFS是RPS的一种增强，它确保了软件中断处理与应用程序发生在同一核心上。</p>
<p>虽然数据包转向可以提高吞吐量，但它对CPU使用的影响比吞吐量更小，而且对延迟几乎没有变化。数据包仍然必须经过相同的数据包转换，并遍历网络堆栈两次。我们的设计，Slim，直接专注于消除容器覆盖网络中每个包的处理开销。</p>
<h3 id="3-概览"><a href="#3-概览" class="headerlink" title="3 概览"></a>3 概览</h3><p>Slim提供了一个低开销的容器覆盖网络，其中覆盖网络中的数据包恰好遍历网络堆栈一次。与其他容器覆盖网络实现一样，Slim创建了一个配置与主机网络完全解耦的虚拟网络。容器没有主机网络接口的可见性，它们只使用操作系统内核创建的虚拟网络接口进行通信。</p>
<p>我们要求（1）Slim易于部署，支持未修改的应用程序二进制文件；（2）灵活，支持各种网络策略，如在每个连接和容器的级别上支持访问控制、速率限制和服务质量(QoS)；而（3）安全，容器无法学习有关物理主机的信息，直接在主机网络上创建连接，或增加其流量转发优先级。</p>
<p><img src="/2021/09/08/container-network-1/image-20210911225923727.png" alt="image-20210911225923727"></p>
<p>图4显示了Slim的架构。它有三个主要组成部分：（1）一个用户空间层，<em>SlimSocket</em>，即与应用程序二进制文件动态链接的模块，（2）一个用户空间路由器，<em>SlimRouter</em>，运行在host namespace中；（3）是一个小型的可选内核模块，<em>SlimKernModule</em>，它通过高级的Slim特性来增强操作系统内核（例如，动态更改访问控制规则，执行安全性）</p>
<p>Slim通过操作连接级的元数据来虚拟化网络。<em>SlimSocket</em>将POSIX套接字接口对外暴露给应用程序二进制文件，以拦截与容器相关的系统调用。当SlimSocket检测到应用程序试图设置连接时，它会向<em>SlimRouter</em>发送请求。SlimRouter设置网络连接后，它将该连接的访问权限作为一个文件描述符传递给容器内的进程。容器内的应用程序然后使用host namespace文件描述符直接向主机网络发送/接收数据包。因为SlimSocket具有与POSIX套接字完全相同的接口，并且Slim动态地将SlimSocket链接到应用程序中，所以不需要修改应用程序的二进制文件。</p>
<p>在Slim中，数据包直接进入主机网络，绕过虚拟网络接口和虚拟交换机；因此，它需要一个单独的机制来支持各种灵活的控制平面策略（例如，访问控制）和数据平面策略（例如，速率限制、QoS）。控制平面策略隔离容器化应用程序的不同组件。数据平面策略限制容器的网络资源使用，并允许网络流量的优先级。在当前的许多覆盖网络实现中，这两种类型的策略实际上都是在数据平面内强制执行的。例如，一个典型的网络防火墙检查每个数据包，以确定它是否被访问控制列表阻止。</p>
<p><em>SlimRouter</em>存储控制平面策略，并在连接设置时强制执行它们。这种方法避免了检查连接中的每个数据包的需要。在创建连接之前，SlimRouter会检查访问控制列表是否允许该连接。当策略更改时，SlimRouter将扫描所有现有连接，并通过<em>SlimKernModule</em>模块删除任何违反更新的访问控制策略的连接的文件描述符。Slim利用现有的内核功能来执行数据平面策略。</p>
<p>直接发送主机名称空间文件描述符到恶意的容器引起了安全问题，例如，如果恶意容器绕过SlimSocket并直接在主机名称空间文件描述符上调用<em>getpeername</em>，那么它将能够学习主机的IP地址。容器还可以用主机网络IP地址调用connect，以直接在主机网络上创建连接，从而绕过覆盖网络。最后，一个容器可以调用<em>setsockopt</em>以增加其流量优先级。</p>
<p>为了保证与今天的容器覆盖网络中相同的安全模型，Slim提供了一种安全模式。当安全模式打开时，Slim会利用内核模块SlimKernModule模块来限制容器内主机名称空间文件描述符的功能。<em>SlimKernModule</em>模块为文件描述符实现了一个轻量级的功能系统。<em>SlimKernModule</em>模块有三个角色：（1)跟踪文件描述符在容器内的传播，(2)根据SlimRouter的请求撤销文件描述符，以及(3)禁止使用这些文件描述符(例如，getpeername、<em>connect</em>、<em>setsockopt</em>）的不安全的系统调用列表。对非恶意应用程序SlimSocket模拟这些系统调用。</p>
<h3 id="4-Slim"><a href="#4-Slim" class="headerlink" title="4 Slim"></a>4 Slim</h3><p>我们首先描述了如何在不需要数据平面中的包转换的情况下实现网络虚拟化，同时保持与当前容器化应用程序的兼容性。然后，我们描述了如何支持灵活的网络策略和恶意容器如何保证安全性。</p>
<p>Slim不会改变虚拟到物理IP映射的存储方式。它们仍然可以存储在外部存储中，也可以通过传播学习获得。与今天的容器覆盖网络一样，Slim依赖于容器在主机网络中的位置的一致和当前的视图。</p>
<h4 id="4-1Connection-based-Network-Virtualization"><a href="#4-1Connection-based-Network-Virtualization" class="headerlink" title="4.1Connection-based Network Virtualization"></a>4.1Connection-based Network Virtualization</h4><p>Slim为容器提供了一种基于连接的网络虚拟化。当在主机上启动容器时，Slim会在主机名称空间中分派一个SlimRouter实例。Slim将用户层套接字<em>SlimSocket</em>连接到容器。当容器内的进程创建连接时，SlimSocket向<em>SlimRouter</em>发送目标IP地址和端口号，而不是发出标准的套接字请求。SlimRouter代表容器创建一个连接，并将主机名称空间文件描述符返回容器。我们首先给出一个例子，说明Slim如何支持传统的阻塞I/O(traditional blocking I/O)。然后，我们描述如何另外使Slim支持非阻塞I/O（traditional blocking I/O）。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912112119544.png" alt="image-20210912112119544"></p>
<p><strong>Support for blocking I/O</strong>图5显示了如何在Slim上的web客户端和web服务器之间创建TCP连接。请考虑到web服务器端。该容器首先使用<em>socket</em>调用创建一个套接字对象。此调用被SlimSocket拦截并转发到<em>SlimRouter</em>，SlimRouter将在主机网络中创建一个套接字对象。当容器调用<em>bind</em>在具有虚拟网络接口IP地址10.0.0.1和端口80的套接字上时，<em>SlimRouter</em>也调用<em>bind</em>在主机网络接口上的IP地址1.2.3.5和一些未使用的端口1234。需要端口转换，因为主机可以在端口80上绑定运行多个web服务器，但主机网络接口只有一个端口80。<em>SlimRouter</em>将更新端口映射。然后，web服务器使用<em>accept</em>来等待传入的TCP连接。此函数调用也被转发到<em>SlimRouter</em>，SlimRouter在主机套接字上等待。</p>
<p>我们移到web客户端旁边。客户端会执行类似的步骤来创建套接字对象。当客户端在IP地址10.0.0.1端口80连接到服务器端时，SlimRouter查找虚拟IP地址10.0.0.1并找到相应的主机IP地址1.2.3.5。然后，SlimRouter在1.2.3.5上接触到目标容器的SlimRouter，以找到相应的主机端口，1234。SlimRouter在1.2.3.5上设置到端口1234的直接连接。TCP握手完成后，<em>accept/connect</em>返回一个文件描述符，其中启用<em>send/recv</em>。SlimRouter将文件描述符传递回容器，SlimSocket使用系统调用<em>dup2</em>用主机名称空间文件描述符替换overlay connection的文件描述符。从那时起，应用程序直接使用主机名称空间文件描述符来发送或接收数据包。</p>
<p><code>int dup2(int oldfd, int newfd);</code>把指定的newfd也指向oldfd指向的文件，也就是说，执行完dup2之后，有newfd和oldfd同时指向同一个文件</p>
<p>为了确保与当前容器化的应用程序兼容，SlimSocket对外暴露了相同的POSIX套接字接口。除了将大多数与套接字相关的系统调用（例如，<em>socket</em>, <em>bind</em>, <em>accept</em>, <em>connect</em>）转发到SlimRouter路由器之外，SlimSocket还小心地维护了预期的POSIX套接字语义。例如，当容器化的应用程序调用<em>getpeername</em>以获取连接另一边的IP地址时，SlimSocket返回overlay IP地址而不是主机IP地址，即使overlay connection的文件描述符已经替换为主机名称空间文件描述符也不是主机IP地址。</p>
<p><strong>Support for non-blocking I/O</strong>今天的大多数应用程序使用非阻塞的I/O API(例如，select，epoll)来实现较高的I/O性能。Slim还必须拦截这些调用，因为它们会与套接字接口交互。例如，epoll会创建一个表示一组文件描述符的元文件描述符。应用程序使用<em>epoll_wait</em>来等待该集合的任何事件，从而消除了创建一个单独的线程来等待每个文件描述符中的事件的需要。在连接设置时，我们必须在epoll的文件描述符集合中更改相应的文件描述符。SlimSocket通过拦截<em>epoll_ctl</em>来跟踪epoll文件描述符和epoll的文件描述符集合之间的映射。对于位于epoll文件描述符集合中的文件描述符上的<em>accept或connect</em>，SlimSocket从epoll文件描述符集合中删除原始overlay网络文件描述符，并将主机名称空间文件描述符添加到集合中。</p>
<p><strong>Service discovery</strong>图5中的示例假设客户端的<em>SlimRouter</em>知道服务器端已经绑定到物理IP1.2.3.4和端口1234。为了自动发现服务器的物理IP地址和端口，我们可以在虚拟网络中的每个节点上存储从虚拟IP/端口到物理IP/端口的映射。不幸的是，每当监听一个新的连接时，此映射就必须更改。</p>
<p>Slim使用分布式机制进行服务发现。Slim保持标准容器覆盖网络在后台运行。当客户端调用<em>connect</em>时，它实际上会在标准容器覆盖网络上创建一个覆盖网络连接。当服务器在标准覆盖网络上的传入连接时，SlimSocket请求<em>SlimRouter</em>查询服务器的物理IP地址和端口，并将它们发送到覆盖连接内的客户端。在安全模式（4.3）下，对从<em>SlimRouter</em>查询的结果进行加密。客户端的<em>SlimSocket</em>将物理IP地址和端口（如果在安全模式下，则进行加密）发给<em>SlimRouter</em>建立主机连接。这意味着在Slim中的连接设置时间比在基于数据包转换的容器覆盖网络上的连接设置时间要长。</p>
<p><strong>4.2 Supporting Flexible Network Policies</strong></p>
<p>本节介绍Slim对控制平面策略和数据平面策略的支持。</p>
<p><strong>Control-plane policies</strong>。Slim支持对覆盖数据包头字段的标准访问控制，如源/目标IP地址和端口。访问控制还可以过滤特定类型的流量（例如，SSH、FTP）或来自特定IP前缀的流量。</p>
<p>在策略是静态的正常情况下，Slim在连接创建时保证访问控制。<em>SlimRouter</em>从容器编排器或网络操作员维护当前访问控制策略的副本。当通过<em>accept/connect</em>创建连接时，<em>SlimRouter</em>将检查创建的连接是否违反任何现有的访问控制策略。如果是，SlimRouter通过返回-1 accept/connect 来拒绝连接。</p>
<p>访问控制策略可以动态更改，而且必须中止违反了更新后的访问控制策略的连接。<em>SlimRouter</em>保持每个连接的状态，包括源和目标IP地址、端口以及相应的主机名称空间文件描述符。当访问控制策略更改时，SlimRouter迭代所有当前连接，以找到更新策略中禁止的连接。SlimRouter通过从容器中删除相应的文件描述符来中止这些连接。从正在运行的进程中删除文件描述符在Linux等操作系统中不是现有的特性。我们在<em>SlimKernModule</em>模块中构建了这个功能。（详情请参见4.3）</p>
<p><strong>Data-plane policies</strong>    Slim支持两种类型的数据平面策略：速率限制和服务质量(QoS)。速率限制限制了容器可以使用的资源量。QoS确保了某些应用程序的性能优于其他应用程序。</p>
<p>Slim重用操作系统内核的现有特性来支持数据平面策略。现代操作系统内核支持单个连接或一组连接的速率限制和QoS。Slim只需设置正确的标识符，让操作系统内核识别生成流量的容器。</p>
<p>在Slim中，在每个连接和每个容器级别都执行速率限制。每个连接速率限制的设置方式与今天使用Linux的具体控制程序<em>tc</em>的覆盖网络类似。对于每个容器的速率限制，Slim首先将<em>net_cls cgroups</em>配置为包含<em>SlimRouter</em>进程。net_cls cgroups标记来自容器或相应<em>SlimRouter</em>的流量具有唯一标识符。然后，<em>SlimRouter</em>在主机网络接口上使用tc设置使用此标识符的流量的速率限制。这样，<em>SlimRouter</em>的网络使用也会受到速率限制的限制。正确解释网络使用情况是为什么每个容器都需要一个单独的<em>SlimRouter实例</em>的基本原因。</p>
<p>服务质量(QoS)也使用tc。SlimRouter使用套接字选项来设置服务类型(ToS)字段。（也就是<em>setsockopt</em>）这样，物理网络上的交换机/路由器将被通知容器流量的优先级。</p>
<p><strong>Compatibility with existing IT tools</strong>一般来说，需要修改IT工具以与SlimRouter交互，以便Slim发挥作用。IT工具通常使用一些用户内核接口(例如，iptables)来注入防火墙和速率限制规则。当使用Slim时，他们应该将这些规则注入到<em>SlimRouter</em>中。因为Slim从本质上是一种基于连接的虚拟化方法，所以我们的方法的一个局限性是它不能支持基于数据包的网络策略（例如，如果数据包的散列与标签匹配，则删除一个overlay数据包）。如果需要基于数据包的策略，则应该使用标准的Linux overlay来代替。</p>
<p>如果基于连接的静态访问控制是唯一需要的网络策略，那么就不需要修改现有的IT工具。如果IT工具阻止了标准容器覆盖网络上的连接，那么它也会在Slim上阻止该连接的服务发现的元数据，从而阻止在Slim上创建主机连接。</p>
<p><strong>4.3 Addressing Security Concerns</strong></p>
<p>Slim包括一个可选的内核模块，<em>SlimKernModule</em>模块，以确保Slim维护与今天的容器覆盖网络相同的安全模型。这个问题涉及到潜在的恶意容器。Slim将主机名称空间文件描述符暴露给容器，因此需要在操作系统内核内部建立一个额外的机制来跟踪和管理访问。<em>SlimKernModule</em>实现了一个基于文件描述符的轻量级和通用的功能系统。SlimKernModule以类似于污染跟踪工具的方式跟踪标记的文件描述符，并过滤这些文件描述符上不安全的系统调用。我们设想这个SlimKernModule也可以被其他系统用于跟踪和控制文件描述符。例如，如果文件服务器触发警报，它可能希望撤销从可疑进程的访问。Slim不能使用像seccomp这样的现有内核特性，因为seccomp不能跟踪已标记的文件描述符。</p>
<p><em>SlimKernModule</em>监视主机名称空间文件描述符在容器内传播的方式。它允许<em>SlimRouter</em>或其他特权进程标记文件描述符。然后，对部分文件描述符的系统调用，如dup、fork和close，它插入复制或删除标记，以跟踪它们的传播。如果容器将文件描述符传递给容器内的其他进程，则也会标记为复制。</p>
<p>带标记的文件描述符在容器内的能力有限。<em>SlimKernModule<em>不允许使用这些文件描述符调用某些不安全的系统调用。例如，在Slim的情况下，带标记的文件描述符不能用于以下系统调用：</em>connect</em>, <em>bind</em>, <em>getsockname</em>,<em>getpeername</em>, <em>setsockopt</em>,等。这防止容器学习其主机IP地址或增加其流量优先级。它还可以防止容器直接创建主机网络连接。对于非恶意容器，<em>SlimSocket</em>和<em>SlimRouter</em>模拟这些被禁止的系统调用的功能。</p>
<p><em>SlimKernModule</em>根据要求撤销标记的文件描述符。要做到这一点，它需要一个进程标识符(pid)和一个文件描述符索引。<em>SlimRouter</em>使用此功能来实现动态访问控制。当现有连接的访问控制列表发生变化时，<em>SlimRouter</em>将通过<em>SlimKernModule</em>删除文件描述符。<em>SlimKernModule</em>撤消文件描述符的所有副本。</p>
<p><strong>Secure versus Non-secure mode</strong>(安全模式与非安全模式) 是否在安全模式下使用Slim(使用SlimKernModule)取决于用例。当容器和物理基础设施处于同一实体的控制下时，例如对于云提供商自己的使用，非安全模式就足够了。不安全模式更容易部署，因为它不需要修改内核。当容器对其他实体的物理基础设施或容器有潜在的不可信时，就需要使用安全模式。安全模式的连接设置时间略长（∼为25%），使得整个连接设置时间比传统的容器覆盖网络长106%（见第6.1章）。</p>
<h3 id="5-Implementation"><a href="#5-Implementation" class="headerlink" title="5 Implementation"></a><strong>5 Implementation</strong></h3><p>我们的Slim的实现是基于Linux和Docker的。我们的原型包括在4中描述的所有特性。<em>SlimSocket</em> SlimRouter <em>SlimKernModule</em> 分别由1184行C、1196行C++（不包括标准库）、和1438行C实现。</p>
<p>我们的原型依赖于一个标准的覆盖网络，Weave，用于服务发现和需要数据平面处理的数据包(例如，ICMP、UDP)。</p>
<p><em>SlimSocket</em>使用 LD_PRELOAD来动态链接到应用程序二进制文件。<em>SlimSocket</em>和<em>SlimRouter</em>之间的通信是通过一个Unix域套接字。在非安全模式下，文件描述符通过<em>sendmsg</em>在<em>SlimRouter</em>和<em>SlimSocket</em>之间传递。对于安全模式，使用SlimKernModule的跨进程文件描述符复制方法传递文件描述符。</p>
<p><em>SlimRouter<em>允许网络运营商根据JSON文件中的源/目标IP地址前缀和端口将访问控制表示为条目列表。SlimRouter有一个命令行接口，使网络操作员可以通过重新加载JSON文件在访问控制列表中发布更改。Slim拒绝在列表中匹配的任何连接。</em>SlimRouter<em>使用</em>htb</em> qdisc来实现速率限制、用 <em>prio</em> qdisc tc 来实现Qos。</p>
<p><em>SlimRouter</em>和<em>SlimKernModule</em>通过<em>SlimKernModule</em>创建的procfs中的虚拟文件进行通信。SlimKernModule将对此文件的写入视为请求。访问虚拟文件需要主机root权限。</p>
<p>SlimKernModule通过替换系统调用表中的函数指针来对系统调用进行交互。SlimKernModule将标记的文件描述符存储在哈希表和不安全的系统调用列表中。SlimKernModule拒绝对标记文件描述符的不安全的系统调用。</p>
<p>SlimKernModule还插入系统调用，如dup、dup2和close，以确保文件描述符标记被适当地传播。对于进程fork(例如，fork、vfork、Linux内核中的克隆)，SlimKernModule使用<em>sched_process fork</em> 作为回调函数。Slim不会改变进程frok的行为。一个fork的进程仍然有<em>SlimSocket</em>的动态连接。</p>
<h3 id="6-Evaluation（评估）"><a href="#6-Evaluation（评估）" class="headerlink" title="6 Evaluation（评估）"></a>6 Evaluation（评估）</h3><p>我们首先在安全和非安全模式下对Slim的性能和CPU利用率进行微基准测试，然后使用四个流行的容器应用程序：内存密钥值存储工具，Memcached；web服务器，Nginx；一个数据库，PostgreSQL；和一个流处理框架，ApacheKafka。最后，我们展示了容器迁移的性能结果。我们的测试床设置与我们的测量研究相同（2.2）。在所有的实验中，我们Weave的默认启动的快速数据平面和默认启用的RFS来参与Slim比较。我们使用Docker来创建容器。</p>
<h4 id="6-1-Microbenchmarks（基准测试细节）"><a href="#6-1-Microbenchmarks（基准测试细节）" class="headerlink" title="6.1 Microbenchmarks（基准测试细节）"></a>6.1 Microbenchmarks（基准测试细节）</h4><p>与2.2中的性能测试类似，我们使用iperf3和NPtcp来测量TCP流的性能。我们使用mpstat来衡量CPU的使用。在我们的40Gbps测试床上运行的一个TCP流在安全和非安全模式下均达到26.8Gbps，延迟时间为11.4µs。Slim的吞吐量与host network上的吞吐量相同，并且比使用RFS的Weave快9%。Slim的延迟也与使用host network相同，而且它比使用RFS的Weave快86%。</p>
<p>使用Slim，创建TCP连接需要更长的路由，因为需要调用用户空间路由器。在我们的测试床上，在一个带有Weave的容器中，创建一个TCP连接需要270µs。采用不安全模式，需要444µs。在安全模式下，它需要556µs。作为参考，在host network上创建一个TCP连接需要58µs。这意味着Slim并不总是更好的，例如，如果一个应用程序有许多短TCP连接。我们在研究的四个应用程序中没有观察到这种效应，因为它们支持长连接，这是一种常见的设计范式。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912131404119.png" alt="image-20210912131404119"></p>
<p>图6：TCP连接的CPU使用和故障分析。在图6a中，Slim和主机线重叠。在图6b中，usr条在底部，可以忽略不计。误差条表示标准差</p>
<p>对于长连接，Slim降低了CPU的使用。我们在改变TCP吞吐量从0到25Gbps的情况下，我们在Slim安全模式、Weave开启RFS下使用mpstat为Slim测量CPU使用。RFS不能达到25Gbps，所以我们省略了该数据点。</p>
<p>图6a显示了按消耗的虚拟核数量计算的总CPU使用。与RFS相比，Slim的CPU开销下降了22-41%；Slim的CPU成本与直接使用主机网络相同。为了确定这种减少的来源，当TCP吞吐量为22.5Gbps时，我们使用mpstat分解不同的组件。</p>
<p>图6b显示了结果。正如预期的那样，CPU成本的最大降低来自于服务软件中断。这些数据包下降了49%：使用Slim，数据包不再需要数据平面转换，并且只需要遍历主机操作系统内核的网络堆栈一次图6b显示了结果。正如预期的那样，CPU成本的最大降低来自于服务软件中断。这些数据包下降了49%，使用Slim，数据包不再需要数据平面转换，并且只需要遍历主机操作系统内核的网络堆栈一次。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912132623212.png" alt="image-20210912132623212"></p>
<p><strong>图7</strong>：两个Slim容器的组合吞吐量的条状图，并对其中一个容器进行了速率限制和访问控制策略的更新。</p>
<p><strong>Network policies</strong>（网络策略）Slim支持访问控制、速率限制和QoS策略，包括当应用于现有连接。我们检查了在使用速率限制和访问控制时的一组示例场景。我们运行两个并行的容器，每个容器都有一个TCP连接。这些连接的另一端是另一台机器上的一个容器。我们使用iperf报告平均每秒吞吐量。图7显示了结果。</p>
<p>如果没有网络策略，每个容器的容量约为18-18.5Gbps。我们首先在一个容器上设置了15gbps的速率限制。该容器的吞吐量会立即下降到14gbps左右，而另一个容器的吞吐量则会增加。在我们设置的速率限制和我们观察到的吞吐量之间发生了轻微的不匹配，我们怀疑这是由于tc是不完美的。我们随后将速率限制设置为10Gbps和5Gbps。正如预期的那样，容器的吞吐量分别下降到10Gbps和5Gbps，而另一个容器的吞吐量增加。</p>
<h4 id="6-2-Applications"><a href="#6-2-Applications" class="headerlink" title="6.2 Applications"></a><strong>6.2 Applications</strong></h4><p>我们用四个真实世界的应用程序来评估Slim：Memcaced、Nginx、PostgreSQL和ApacheKafka。从这一点起，我们的评估使用了在安全模式下运行的Slim。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912133258237.png" alt="image-20210912133258237"></p>
<p>图8：<em>Memcached</em>使用Weave（采用各种配置）和Slim的吞吐量和延迟。图8a中的误差条显示了每秒完成的内存缓存操作的标准偏差。</p>
<h5 id="6-2-1-Memcached"><a href="#6-2-1-Memcached" class="headerlink" title="6.2.1 Memcached"></a><strong>6.2.1 Memcached</strong></h5><p>我们测量了Memcached在Slim的性能。我们在两台物理机器上各创建一个容器；一个运行Memcached(v1.5.6)服务器，另一个容器运行一个标准的Memcached benchmark工具，由redislab开发的<em>memtier_benchmark</em>。基准测试工具会产生4个线程。每个线程创建50个到Memcached服务器的5个TCP连接，并报告每秒平均响应数、响应memcache命令的平均延迟以及响应延迟的分布为(SET：GET比率=1：10)。</p>
<p>Slim提高了Memcached的吞吐量（相对于Weave）。图8a显示了在具有不同配置的Slim和Weave上每秒完成的Memcached操作的总数。接收流量转向(RFS)是我们最好的调优配置，但Slim的性能仍然比它好71%。使用默认的覆盖网络设置(随机IRQ负载平衡)，Slim的性能超过Weave79%。Slim的吞吐量在主机模式的3%以内。</p>
<p>Slim还减少了Memcached的延迟。图8b显示了完成Memcached操作的平均延迟。与RFS相比，使用Slim的平均延迟减少了42%。默认设置（随机IRQ负载均衡）、RPS和RFS的延迟没有显著差异（在5%内）。Slim的延迟与主机模式完全相同。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912152756280.png" alt="image-20210912152756280"></p>
<p><strong>图9</strong>：<em>Memcached</em>SET和GET操作的延迟分布，说明了尾部延迟效应。Slim线和主机线重叠。</p>
<p>Slim还减少了Memcached的尾部延迟。图9显示了SET和GET操作的延迟的CDF。默认配置（即IRQ负载平衡）的尾部延迟行为最差。同步开销依赖于时间内核状态，因此延迟不可预测。RPS和RFS部分消除了同步开销，提高了可预测性。与最佳配置RFS相比，Slim减少了99.9%的尾部延迟41%。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912152957785.png" alt="image-20210912152957785"></p>
<p>图10：对 <em>Memcached</em>的客户端和服务器的CPU使用。误差条表示标准差。</p>
<p>Slim降低了每个操作的CPU使用。当<em>memtier benchmark</em>运行时，我们测量客户端和Memcached服务器上的平均CPU使用。图10显示了结果。客户端的CPU总使用相似，而服务器上的Slim的使用比RFS低25%。请记住，Slim每秒多执行71%的操作。正如预期的那样，服务软件中断中的CPU使用在Slim中下降。我们还比较了当吞吐量被限制为相同时的CPU使用。相对于Weave，Slim在Memcached客户端上降低了41%的CPU使用，在Memcached服务器上降低了56%。</p>
<h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><strong>Nginx</strong></h5><p><img src="/2021/09/08/container-network-1/image-20210912153548295.png" alt="image-20210912153548295"></p>
<p><strong>图11</strong>：Nginx的CPU使用分解。误差条表示标准差。</p>
<p>我们在一个容器中运行一台Nginx(v1.10.3)服务器，在另一个容器中运行一个标准的web服务器基准测试工具wrk2。这两个容器都在两个不同的物理机器上。该工具wrk2将生成2个线程，以创建总共100个到Nginx服务器的100个连接，以请求HTML文件。此工具允许我们设置吞吐量（请求/秒），并输出延迟。我们在Nginx服务器上设置了两个HTML文件(1KB，1MB)。Nginx服务器的CPU使用显著降低。我们使用mpstat来分解当RFS、Slim和主机模式时，Nginx服务器的CPU使用。图11显示了当文件大小为1KB、吞吐量为60K请求/秒时的CPU使用分解，以及当文件大小为1MB、吞吐量为3K请求/秒时的CPU使用分解。(我们选择60K请求/秒和3K请求/秒，因为它们接近RFS可以处理的限制。)对于1KB文件，CPU使用比RFS降低了24%。对于1MB的文件，CPU使用比RFS降低了22%。请注意，CPU使用的减少来自于服务内核软件中断的CPU周期的减少。Slim和主机之间的CPU使用仍然有5%-6%的差距。我们预计这个差距来自于Slim中较长的连接设置时间。与我们的Memcached基准测试不同，我们观察到wrk2可以动态地创建TCP连接来发送HTTP请求。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912153824855.png" alt="image-20210912153824855"></p>
<p><strong>图12</strong>：Nginx服务器的延迟。误差条表示标准差。</p>
<p>虽然Slim提高了CPU使用，但Nginx延迟自然方差会了延迟的噪声。基准测试工具wrk2报告Nginx延迟的平均值和标准差。图12显示了结果。标准差远远大于平均延迟的差值。</p>
<h5 id="6-2-3-PostgreSQL"><a href="#6-2-3-PostgreSQL" class="headerlink" title="6.2.3 PostgreSQL"></a><strong>6.2.3 PostgreSQL</strong></h5><p>我们在一个容器中部署了一个关系数据库PostgreSQL（9.5版），然后使用其默认的基准测试工具pgbench对其在另一个容器中的性能进行基准测试。该工具pgbench实现了标准的TPC-B基准测试。</p>
<p>它创建了一个包含100万个银行账户的数据库，并使用4个线程执行交易，总共100个连接。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912154159822.png" alt="image-20210912154159822"></p>
<p><strong>图13</strong>：PostgreSQL和Kafka的CPU使用。误差条表示标准差。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912154235036.png" alt="image-20210912154235036"></p>
<p><strong>图14</strong>：PostgreSQL和kafka的延迟。误差条表示标准差。</p>
<p>Slim降低了PostgreSQL服务器的CPU使用。我们设置了pgbench以每秒生成300个事务。(我们选择每秒300笔事务，因为它接近RFS可以处理的事务。)图13a显示了PostgreSQL服务器的CPU使用分解。与RFS相比，Slim降低了CPU使用22%，CPU使用与使用主机模式网络完全相同。请注意，在这里，CPU使用的减少远远小于Memcached和Nginx。其原因是PostgreSQL服务器在用户空间中花费了更大比例的CPU周期，即处理SQL查询。因此， overlay network所消耗的CPU周期的比例更小。</p>
<p>与Nginx类似，由于磁盘操作的参与，PostgreSQL的延迟自然有很高的方差，并且很难得出Slim对延迟的任何好处。基准测试工具pgbench报告PostgreSQL延迟的平均值和标准差。图14a显示了结果。标准差远远大于平均延迟的差值。</p>
<h5 id="6-2-4-Apache-Kafka"><a href="#6-2-4-Apache-Kafka" class="headerlink" title="6.2.4 Apache Kafka"></a><strong>6.2.4 Apache Kafka</strong></h5><p>我们现在评估一个流行的数据流框架，Apache Kafka。它用于构建实时数据处理应用程序。我们在一个容器中运行Kafka（第2.0.0版），并在不同的物理机器上的另一个容器中运行kafka的默认基准测试工具，<em>kafka-producer-perf-test</em>。</p>
<p>Slim降低了Kaffa服务器和Kafka客户端的CPU使用。我们使用kafka-producer-perf-test去设置吞吐量为每秒500K条消息(我们选择每秒500K条消息，因为它接近RFS可以处理的信息。)，每个消息为100字节，批处理大小为8192。该工具产生10个线程，并行生成消息。图13b显示了CPU利用率的分解情况。使用Slim，Kafka服务器的总CPU利用率减少了10%。CPU利用率的降低甚至比PostgreSQL更小，因为Kafka在用户空间处理上花费的时间更多。</p>
<p>Slim减少了kafka中的消息延迟。基准工具kafka-producer-perf-test，报告了kafka的延迟。图14b显示了结果。与RFS相比，Kafka的延迟减少了0.28ms（28%）。使用Slim和主机模式之间仍存在0.09ms的延迟间隔。</p>
<h4 id="6-3-Container-Migration（容器迁移）"><a href="#6-3-Container-Migration（容器迁移）" class="headerlink" title="6.3 Container Migration（容器迁移）"></a><strong>6.3 Container Migration</strong>（容器迁移）</h4><p>Slim支持容器迁移。在我们的测试床上，我们将一个Memcached的容器从一个物理服务器迁移到40Gbps网络上的另一个物理服务器。我们测试了20次迁移。容器的IP地址在整个迁移过程中保持不变。同样地，我们也不更改主机网络的路由表。从文件系统中提取的容器镜像为58M字节。</p>
<p><img src="/2021/09/08/container-network-1/image-20210912154957014.png" alt="image-20210912154957014"></p>
<p><strong>表4</strong>：迁移<em>Memcached</em>容器的时间。±后面的数字表示标准差。</p>
<p>使用Slim可以略微减缓容器的迁移。表4是在Weave和Slim上的平均容器迁移时间的分类。总的来说，Slim可以将容器迁移从3.34s减慢到3.76s。Slim不会改变大部分的迁移过程。额外的开销主要用于恢复文件系统。使用Slim，容器具有包含SlimSocket的附加磁盘卷和一个虚拟文件，以支持SlimSoicket和<em>SlimRouter</em>之间在UNIX域套接字上的通信。我们怀疑额外的磁盘卷会减慢文件系统的恢复过程。此外，使用Slim启动容器还增加了少量的额外开销。</p>
<h3 id="7-Discussion-讨论"><a href="#7-Discussion-讨论" class="headerlink" title="7 Discussion(讨论)"></a><strong>7 Discussion</strong>(讨论)</h3><p><strong>Connection Setup Time (连接建立时间)</strong>Slim的一个缺点是连接设置时间明显长得多（6.1）。这可能对具有许多短连接的应用程序不利。Slim允许容器中的独立应用程序通过分离<em>SlimSocket</em>来选择退出。在未来，我们希望在每个连接的级别可以有选择的选择退出。我们可以让（1)允许开发人员指定选择退出的连接，也可以让(2）根据预测的流大小自动选择退出。</p>
<p><strong>Container Live Migration（容器热迁移）</strong>虽然Slim确实支持静态容器迁移，但它目前不支持容器实时迁移。在迁移过程中，所有TCP连接都断开，也不迁移内存状态。但是，在实时迁移中，必须完全恢复实时应用程序状态，包括在操作系统内核中等待事件的应用程序线程等状态。Docker目前正在试验使用criu进行实时检查指向和恢复，但它关注的是单个主机的更简单的情况。如果可以构建一个实际的实时容器迁移系统，Slim将使其更加困难，因为：（1)容器的状态现在包括主机名称空间文件描述符，(2)数据平面策略对主机连接标识符(例如，速率限制），在迁移时需要正确翻译。</p>
<p><strong>UDP.</strong>本文的重点是通过将操作从数据平面转移到连接设置，来提高面向连接等TCP的协议的容器通信性能。这对UDP等无连接协议带来了挑战。Slim可能可以通过使用类似的机制支持TCP，通过拦截<em>socket</em>, <em>bind</em>, <em>connect</em>, <em>sendto</em>,recvfrom来支持UDP。然而，我们选择在原型中不这样做有两个原因。首先，我们没有一个良好的机制来支持UDP的灵活的网络策略。在UDP中，文件描述符并不描述单个网络对，而是描述一个开放的端口，虚拟网络中的每个节点都可以向其发送数据包。其次，数据中心中UDP最常见的用例是避免连接设置的开销；由于Slim使连接设置更昂贵，它将破坏其中一些好处。相反，为了使用可能混合使用TCP和UDP数据包的未修改的应用程序，我们的原型只是将UDP流量导向Weave。</p>
<p><strong>Packet-based Network Policy（基于包的网络策略）</strong>Slim的一个限制性是，它支持基于连接的网络策略，而不是基于数据包的网络策略。例如，可以设置虚拟网络以防止某些容器访问后端数据库；Slim支持这种访问控制。基于数据包的策略做法是如果覆盖数据包的哈希与签名相匹配，则允许系统删除数据包。。在Slim上，从未构建过虚拟覆盖数据包，因此检查签名将非常昂贵。如果需要基于数据包的网络策略，则应使用标准的覆盖网络。</p>
<p><strong>LD_PRELOAD</strong>我们的原型使用LD_PRELOAD来将SlimSocket动态链接到未修改的应用程序二进制文件中。有些系统假设是静态链接的应用程序二进制文件（例如，用Go编写的应用程序）。它们可以通过修补应用程序二进制文件以使用SlimSocket而不是POSIX套接字，也能使用Slim。我们不实现这个功能支持我们的原型。</p>
<p><strong>Error Code</strong>我们目前的原型实现在一个重要的方式上是不透明的。当访问控制列表发生更改，要求Slim撤销文件描述符时，应用程序在使用该文件描述符时相对于Weave会收到不同的错误代码。在Slim中，对被撤销的文件描述符的发送返回一个错误的文件描述符错误代码，而在Weave中，数据包将被静默地丢弃。我们相信有可能解决这个问题，但我们的基准测试应用程序不需要它。</p>
<p><strong>SmartNICs</strong></p>
<p>最近的一个研究趋势是探索将常见情况下的网络数据平面操作转向硬件。例如，Catapult会将虚拟机仿真所需的数据包封装移动到硬件上。然而，Catapult在物理链路上运行，因此，为了卸载覆盖网络处理，需要修改Linux以接受在其物理网络接口上的虚拟网络数据包。SR-IOV是一种商品硬件，但它面临着与malvlan模式相同的问题。（见第2.1节。）FlexNIC提出了一种灵活的模型，可以包含应用程序、客户操作系统和虚拟机数据包管理，但迄今为止它只是实验性的硬件。虽然新的硬件支持可能会越来越可用，但我们已经表明，这种硬件支持对于容器的高效虚拟覆盖网络并不是必要的；容器操作系统具有在连接设置时执行虚拟化所需的所有信息。</p>
<h3 id="8-Related-Work-相关工作"><a href="#8-Related-Work-相关工作" class="headerlink" title="8 Related Work(相关工作)"></a><strong>8 Related Work(相关工作)</strong></h3><p><strong>Network namespace</strong> 将资源从主机映射到容器中并不是一个新主意。在Plan9中，资源，如文件系统中的目录或进程标识符，被直接映射在名称空间之间。我们的工作在网络环境中回顾了Plan9的想法，但以性能作为一个目标，而不是可移植性。今天的Linux网络名称空间可以在每个设备的级别上工作，因此不足以支持基于连接的网络虚拟化。Slim使用Linux网络名称空间将容器与使用主机网络接口隔离.</p>
<p><strong>Host support for effificient virtual networking(主机支持的高效的虚拟网络)</strong>主机对高效虚拟网络的支持是一个旧话题，主要是在虚拟机的背景下。Menon等人。为高效虚拟网络接口仿真共同设计虚拟网络接口驱动程序。套接字外包Socket outsourcing、VMCI套接字VMCI socket和Slipstream改善了主机内网络。FreeFlow重定向RDMA库调用，以创建快速容器RDMA网络。据我们所知，Slim是第一个为未修改的容器化应用程序在TCP连接设置时提供网络虚拟化的工作。</p>
<p><strong>Redirecting system calls(重定向系统调用)</strong>重定向系统调用对于许多用途都是一种有用的技术，如污染跟踪、构建用户级文件系统[16]和执行其他高级操作系统内核特性（比如，sandboxing record and replay  intrusion detection。在网络上下文中，mTCP会重定向套接字调用，以构建用户级的网络堆栈。网络内核重定向套接字调用，以将网络堆栈与虚拟机映像解耦。</p>
<p><strong>Separation of control- and data-plane（控制平面和数据平面的分离）</strong>Slim的性能增益来自于将网络虚拟化逻辑从数据移动到控制平面。控制平面和数据平面的分离是提高在灵活网络中构建快速数据平面操作系统和路由的系统性能的著名技术。</p>
<h3 id="9-Conclusion（结论）"><a href="#9-Conclusion（结论）" class="headerlink" title="9 Conclusion（结论）"></a><strong>9 Conclusion（结论）</strong></h3><p>容器已经成为托管分布式应用程序的实际方法。提供可移植性的关键组件，容器覆盖网络，在吞吐量、延迟和CPU使用方面造成了巨大的开销，因为它向数据平面添加了一层。我们提出了Slim，一种低开销的容器覆盖网络，它通过操作连接级元数据来实现网络虚拟化。Slim透明地支持未经修改的、潜在恶意的应用程序。Slim提高了内存中密钥值存储的吞吐量71%，并减少了42%的延迟。Slim将内存中密钥值存储的CPU使用减少了56%，web服务器减少了22%-24%，数据库服务器减少了22%，流处理框架减少了10%。</p>
<p>Slim的源代码在<a href="https://github.com/danyangz/slim。" target="_blank" rel="noopener">https://github.com/danyangz/slim。</a></p>

    </div>

    
    
    
	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	  
	</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Container/" rel="tag"><i class="fa fa-tag"></i> Container</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/24/go-swagger1/" rel="prev" title="go-swagger学习与使用">
      <i class="fa fa-chevron-left"></i> go-swagger学习与使用
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#摘要"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-介绍"><span class="nav-number">2.</span> <span class="nav-text">1 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-背景"><span class="nav-number">3.</span> <span class="nav-text">2 背景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-Container-Overlay-Network"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 Container Overlay Network</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-容器覆盖网络中的开销"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 容器覆盖网络中的开销</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-一个覆盖的网络包的路径"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.2.1 一个覆盖的网络包的路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-定量开销"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2.2 定量开销</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-已知技术调整数据面"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 已知技术调整数据面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-概览"><span class="nav-number">4.</span> <span class="nav-text">3 概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Slim"><span class="nav-number">5.</span> <span class="nav-text">4 Slim</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1Connection-based-Network-Virtualization"><span class="nav-number">5.1.</span> <span class="nav-text">4.1Connection-based Network Virtualization</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Implementation"><span class="nav-number">6.</span> <span class="nav-text">5 Implementation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Evaluation（评估）"><span class="nav-number">7.</span> <span class="nav-text">6 Evaluation（评估）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-Microbenchmarks（基准测试细节）"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 Microbenchmarks（基准测试细节）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-Applications"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 Applications</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-1-Memcached"><span class="nav-number">7.2.1.</span> <span class="nav-text">6.2.1 Memcached</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Nginx"><span class="nav-number">7.2.2.</span> <span class="nav-text">Nginx</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-3-PostgreSQL"><span class="nav-number">7.2.3.</span> <span class="nav-text">6.2.3 PostgreSQL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-4-Apache-Kafka"><span class="nav-number">7.2.4.</span> <span class="nav-text">6.2.4 Apache Kafka</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-Container-Migration（容器迁移）"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 Container Migration（容器迁移）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Discussion-讨论"><span class="nav-number">8.</span> <span class="nav-text">7 Discussion(讨论)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Related-Work-相关工作"><span class="nav-number">9.</span> <span class="nav-text">8 Related Work(相关工作)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Conclusion（结论）"><span class="nav-number">10.</span> <span class="nav-text">9 Conclusion（结论）</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="萧逸小杨"
      src="/images/yteng.jpg">
  <p class="site-author-name" itemprop="name">萧逸小杨</p>
  <div class="site-description" itemprop="description">不断学习、不断更新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">162</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/XiaoYiXiaoYang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;XiaoYiXiaoYang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1409026014@qq.com" title="QQ邮箱 → 1409026014@qq.com"><i class="fa fa-fw fa-envelope"></i>QQ邮箱</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.yteng3456.xyz/" title="http:&#x2F;&#x2F;www.yteng3456.xyz" rel="noopener" target="_blank">个人网站</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">萧逸小杨</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '4zqRlLDezT2DPxCpoU8FYiPN-gzGzoHsz# Your leancloud application appid',
    appKey: 'saQbdXsTkRfwnmsossKSYMcW# Your leancloud application appkey',
    placeholder: "欢迎评论指点",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
