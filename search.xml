<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ovs port vlan属性设置</title>
      <link href="/2022/07/05/ovs-port-vlan/"/>
      <url>/2022/07/05/ovs-port-vlan/</url>
      
        <content type="html"><![CDATA[<h2 id="vlan-模式"><a href="#vlan-模式" class="headerlink" title="vlan 模式"></a>vlan 模式</h2><p>access、trunk、native-tagged、native-untagged</p><h3 id="收发包行为"><a href="#收发包行为" class="headerlink" title="收发包行为"></a>收发包行为</h3><p>vlanid为0和没有vlan tag一样的处理。<br>native-tagged端口和native-untagged端口的native vlan即为port的tag值</p>  <blockquote class="pullquote mindmap mindmap-md"><ul><li>OVS vlan属性收发包<ul><li>access<ul><li>收<ul><li>没有vlan tag，接收，并打上端口vlan(tag=0不生效)</li><li>有vlan tag且vlanid非0，丢弃</li></ul></li><li>发<ul><li>发出去的报文不带vlan</li></ul></li></ul></li><li>trunk<ul><li>收<ul><li>trunk为空收：<ul><li>报文带vlan，允许进入</li><li>报文不带vlan，允许进入</li></ul></li><li>trunk不为空收<ul><li>报文带vlan tag，vlan id是否在允许之列，收</li><li>报文不带vlan tag，丢弃</li></ul></li></ul></li><li>发<ul><li>带着原始vlan发出</li></ul></li></ul></li><li>native-tagged<ul><li>收<ul><li>报文带vlan tag，vlan id是否在允许之列，收</li><li>报文不带vlan tag，接收，并打上端口的native vlan</li></ul></li><li>发<ul><li>带着原始vlan发出</li></ul></li></ul></li><li>native-untagged<ul><li>收<ul><li>报文带vlan tag，vlan id是否在允许之列，收</li><li>报文不带vlan tag，接收，并打上端口的native vlan</li></ul></li><li>发<ul><li>vid == native vlan，不带vlan，发出</li><li>vid != native vlan，带原始vlan发出</li></ul></li></ul></li></ul></li></ul></blockquote><p>当端口vlan_mode为native-tagged或native-untagged时，native vlan也在其对应的广播域中</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="创建两个vm"><a href="#创建两个vm" class="headerlink" title="创建两个vm"></a>创建两个vm</h3><pre><code>ip netns add vm1ip link add vm1-vif type veth peer name vm1ip link set vm1 netns vm1ip netns exec vm1 ip link set vm1 address 00:00:00:00:00:03ip netns exec vm1 ip addr add 10.10.10.2/24 dev vm1ip netns exec vm1 ip link set vm1 upip link set vm1-vif upip netns add vm2ip link add vm2-vif type veth peer name vm2ip link set vm2 netns vm2ip netns exec vm2 ip link set vm2 address 00:00:00:00:00:04ip netns exec vm2 ip addr add 10.10.10.3/24 dev vm2ip netns exec vm2 ip link set vm2 upip link set vm2-vif up</code></pre><h3 id="连接vm网卡和网桥"><a href="#连接vm网卡和网桥" class="headerlink" title="连接vm网卡和网桥"></a>连接vm网卡和网桥</h3><pre><code>ovs-vsctl add-br -br-intovs-vsctl add-port br-int vm1-vifovs-vsctl add-port br-int vm2-vif</code></pre><p>效果如图<br><img src="/2022/07/05/ovs-port-vlan/img-20220705225523.png" alt></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h4><p>tcpdump和ovs-tcpdump工具可以抓到一路上OVS对vlan的处理。</p><p>如果使用ovs-tcpdump，ovs-tcpdump在守护程序中创建交换机镜像端口，并执行以侦听这些端口。当实例退出时，它会清理它创建的镜像端口。</p><p>如果用系统tcpdump抓包，抓的是经过vm网卡veth pair的流量。</p><p>抓包点如下</p><pre><code>vm1-eth0-(tcpdump)vm1-vif(ovs-tcpdump)-OVS Bridge-vm2-vif-vm2-eth0</code></pre><h3 id="access模式"><a href="#access模式" class="headerlink" title="access模式"></a>access模式</h3><p>收包：收包不带vlan/vlan为0，则打上tag，带vlan，则丢弃<br>发包：只会发vlan为端口vlan的包，发包不带vlan</p><h4 id="tag-0"><a href="#tag-0" class="headerlink" title="tag=0"></a>tag=0</h4><p>tag=0时不生效，抓到的包并没有打上vlanid为0的tag(处理收包时也类似，vlan_id为0则表示当作没有vlan处理)</p><pre><code>ovs-vsctl set Port vm1-vif vlan_mode=accessovs-vsctl set Port vm2-vif vlan_mode=accessovs-vsctl set Port vm1-vif tag=0ovs-vsctl set Port vm2-vif tag=0</code></pre><p><img src="/2022/07/05/ovs-port-vlan/img-20220707221449.png" alt></p><p><strong>收包 不带vlan</strong></p><ul><li>vm1发出不带vlan的包，vm1-vif port access tag=0处理后还是不带vlan<br><img src="/2022/07/05/ovs-port-vlan/img-20220707222722.png" alt><br><img src="/2022/07/05/ovs-port-vlan/img-20220707222806.png" alt></li></ul><p><strong>收包 带vlan 0</strong></p><ul><li>vm1发出带vlan0的包, vm1-vif处理后不带vlan<br><img src="/2022/07/05/ovs-port-vlan/img-20220711222809.png" alt></li></ul><p><strong>收包 带vlan 11</strong></p><ul><li>vm1 发出带vlan 11的包，vm1-vif port access tag=0处理后丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220711222511.png" alt><br><img src="/2022/07/05/ovs-port-vlan/img-20220711222607.png" alt></li></ul><p><strong>发包 不带vlan</strong></p><ul><li>vm2-vif通过不带vlan的包，以不带vlan转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220711223215.png" alt></li></ul><p><strong>发包 带vlan 0</strong><br>带vlan 0的数据包无法进入</p><p><strong>发包 带vlan 11</strong></p><ul><li>设置vm1-vif access模式tag为11，，vm2-vif access模式保持tag=0</li><li>带vlan 11的数据包不会被转发到vm2-vif口<br><img src="/2022/07/05/ovs-port-vlan/img-20220713200925.png" alt></li></ul><h4 id="tag-0-1"><a href="#tag-0-1" class="headerlink" title="tag!=0"></a>tag!=0</h4><pre><code>ovs-vsctl set Port vm1-vif vlan_mode=accessovs-vsctl set Port vm2-vif vlan_mode=accessovs-vsctl set Port vm1-vif tag=10ovs-vsctl set Port vm2-vif tag=10</code></pre><p><img src="/2022/07/05/ovs-port-vlan/img-20220707222905.png" alt></p><p><strong>收包 不带vlan</strong></p><ul><li>vm1发出不带vlan的包，vm1-vif port access tag=10处理后，带上vlan 10<br><img src="/2022/07/05/ovs-port-vlan/img-20220707223104.png" alt></li></ul><p><strong>收包 带vlan 0</strong><br>设置linux 子接口</p><pre><code>ip netns exec vm1 vconfig add vm1 0ip netns exec vm1 ifconfig vm1 0.0.0.0ip netns exec vm1 ifconfig vm1.0 10.10.10.2</code></pre><ul><li>vm1 发出vlan 0的数据包，vm1-vif port access 处理后，带上vlan 10<br><img src="/2022/07/05/ovs-port-vlan/img-20220710224012.png" alt><br><img src="/2022/07/05/ovs-port-vlan/img-20220710224207.png" alt></li></ul><p><strong>收包带vlan 10</strong><br>设置linux 子接口</p><pre><code>ip netns exec vm1 vconfig add vm1 10ip netns exec vm1 ifconfig vm1 0.0.0.0ip netns exec vm1 ifconfig vm1.10 10.10.10.2</code></pre><ul><li>vm1发出带vlan 10的包，vm1-vif port access 处理后，被丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220710223431.png" alt><br><img src="/2022/07/05/ovs-port-vlan/img-20220710223519.png" alt></li></ul><p><strong>收包 带vlan11</strong></p><pre><code>ip netns exec vm1 vconfig add vm1 11ip netns exec vm1 ifconfig vm1 0.0.0.0ip netns exec vm1 ifconfig vm1.11 10.10.10.2</code></pre><ul><li>vm1发出带vlan 11的数据包，vm1-vif port处理后，被丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220713201315.png" alt></li></ul><p><strong>发包 不带vlan</strong></p><ul><li>vm1-vif设置trunk模式且trunks为空，vm2-vif设置access模式tag=10，vm1-vif接收不带vlan的包后没有被转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713201940.png" alt></li></ul><p><strong>发包 带vlan 0</strong><br>带vlan 0的数据包无法进入</p><p><strong>发包 带vlan 10</strong></p><ul><li>vm1-vif设置access模式tag=10，vm2-vif设置access模式tag=10</li><li>vm1-vif port将vlan 10的数据包转发到vm2-vif，vm2-vif处理后以不带vlan转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220713203016.png" alt></li></ul><p><strong>发包 带vlan 11</strong></p><ul><li>vm1-vif设置access模式tag=11， vm2-vif设置access模式tag=10</li><li>vm1-vif port收到vlan 11的数据包后没有转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713203212.png" alt></li></ul><h3 id="trunk模式"><a href="#trunk模式" class="headerlink" title="trunk模式"></a>trunk模式</h3><p>trunks为空<br>收包：收包不带vlan或者带vlan或者vlanid为0(进入后不带vlan)，允许进入<br>发包：带着原始vlan转发<br>trunks不为空<br>收包：带vlan且在vlan_range中，才允许进入<br>发包：在vlan_range中，会带着原始vlan转发</p><h5 id="trunks为空"><a href="#trunks为空" class="headerlink" title="trunks为空"></a>trunks为空</h5><p>在不配置vlan时，ovs port默认是trunk all的，可以抓包看到对应的数据包没有带vlan，也都被允许通过了。</p><pre><code>ovs-vsctl set Port vm1-vif vlan_mode=trunkovs-vsctl set Port vm2-vif vlan_mode=trunkovs-vsctl set Port vm1-vif trunks=[]ovs-vsctl set Port vm2-vif trunks=[]</code></pre><p><img src="/2022/07/05/ovs-port-vlan/img-20220713213515.png" alt></p><p><strong>收到不带vlan的包</strong></p><ul><li>vm1发出不带vlan的数据包，vm1-vif处理后继续不带vlan<br><img src="/2022/07/05/ovs-port-vlan/img-20220713203933.png" alt></li></ul><p><strong>收到带vlan 0的包</strong></p><ul><li>vm1 发出带vlan 0的包，vm1-vif处理后不带vlan，且允许通过。<br><img src="/2022/07/05/ovs-port-vlan/img-20220710225805.png" alt><br><img src="/2022/07/05/ovs-port-vlan/img-20220710225731.png" alt></li></ul><p><strong>收到带vlan 10的包</strong></p><ul><li>vm1发出带vlan 10的包，vm1-vif 处理后带着原vlan转发，<br><img src="/2022/07/05/ovs-port-vlan/img-20220710230349.png" alt><br><img src="/2022/07/05/ovs-port-vlan/img-20220713204049.png" alt></li></ul><p><strong>发包 不带vlan</strong></p><ul><li>vm1-vif转发不带vlan的包到vm2-vif</li><li>vm2-vif继续以不带vlan转发vm2<br><img src="/2022/07/05/ovs-port-vlan/img-20220713204432.png" alt></li></ul><p><strong>发包 带vlan 0</strong><br>带vlan 0的数据包无法进入</p><p><strong>发包 带vlan 10</strong></p><ul><li>设置vm1-vif 为access模式tag=10</li><li>vm1-vif收到vlan 10的数据包转发到vm2-vif， vm2-vif以原vlan转发到vm2<br><img src="/2022/07/05/ovs-port-vlan/img-20220713204647.png" alt></li></ul><h5 id="trunks不为空"><a href="#trunks不为空" class="headerlink" title="trunks不为空"></a>trunks不为空</h5><p>在配置vlan后，ovs port只能收在trunk范围的包</p><pre><code>ovs-vsctl set Port vm1-vif vlan_mode=trunkovs-vsctl set Port vm1-vif vlan_mode=trunkovs-vsctl set Port vm1-vif trunks=[10]ovs-vsctl set Port vm2-vif trunks=[10]</code></pre><p><img src="/2022/07/05/ovs-port-vlan/img-20220713213553.png" alt></p><p><strong>收到不带vlan的包</strong></p><ul><li>vm1 发出不带vlan的包，vm1-vif处理后，被丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220710231215.png" alt></li></ul><p><strong>收到带vlan 0的包</strong></p><ul><li>vm1 发出带vlan 0的包，vm1-vif处理后不在允许范围内被丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220710231542.png" alt></li></ul><p><strong>收到带vlan 10的包</strong></p><ul><li>vm1 发出带vlan10的包，vm1-vif处理后允许通过，vm2-vif允许通过，vm2收到带vlan10的包后丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220710231015.png" alt></li></ul><p><strong>收到带vlan 11的包</strong></p><ul><li>vm1 发出带vlan 0的包，vm1-vif处理后不在允许范围内被丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220710231738.png" alt></li></ul><p><strong>发包 不带vlan</strong></p><ul><li>设置vm1-vif trunk模式，trunks=[]</li><li>vm1-vif处理不带vlan的数据包不会转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713205845.png" alt></li></ul><p><strong>发包 带vlan 0</strong><br>带vlan 0的数据包无法进入</p><p><strong>发包 带vlan 10</strong></p><ul><li>设置vm1-vif access模式，tag=10</li><li>vm1-vif处理vlan 10的数据包转发到vm2-vif，vm2-vif以vlan 10转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220713210045.png" alt></li></ul><p><strong>发包 带vlan 11</strong></p><ul><li>设置vm1-vif access模式，tag=10</li><li>vm1-vif处理vlan 11的数据包不会转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713210138.png" alt></li></ul><h3 id="native-tagged模式"><a href="#native-tagged模式" class="headerlink" title="native-tagged模式"></a>native-tagged模式</h3><p>native-vlan设置即tag列<br>收包：报文不带vlan，则打上native vlan进入，报文带vlan且在允许之列，则进入<br>发包：带着原始vlan发出</p><h4 id="native-vlan和trunks重合"><a href="#native-vlan和trunks重合" class="headerlink" title="native vlan和trunks重合"></a>native vlan和trunks重合</h4><pre><code>ovs-vsctl set Port vm1-vif vlan_mode=native-taggedovs-vsctl set Port vm2-vif vlan_mode=native-taggedovs-vsctl set Port vm1-vif trunks=[10]ovs-vsctl set Port vm1-vif tag=10ovs-vsctl set Port vm2-vif trunks=[10]ovs-vsctl set Port vm2-vif tag=10</code></pre><p><img src="/2022/07/05/ovs-port-vlan/img-20220713213626.png" alt></p><p><strong>收包 不带vlan</strong></p><ul><li>vm1发出不带vlan的数据包，vm1-vif处理后带上native vlan 10<br><img src="/2022/07/05/ovs-port-vlan/img-20220713211909.png" alt></li></ul><p><strong>收包 带vlan 0</strong></p><ul><li>vm1发出带vlan 0的数据包，vm1-vif处理后带上native vlan 10<br><img src="/2022/07/05/ovs-port-vlan/img-20220713212047.png" alt></li></ul><p><strong>收包 带vlan 10</strong></p><ul><li>vm1发出带vlan 10的数据包，vm1-vif允许带着原始vlan进入<br><img src="/2022/07/05/ovs-port-vlan/img-20220713212213.png" alt></li></ul><p><strong>收包 带vlan 11</strong></p><ul><li>vm1 发出带vlan 11的数据包，不在允许之列，vm1-vif丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220713212418.png" alt></li></ul><p><strong>发包 不带vlan</strong></p><ul><li>vm1-vif设置trunk模式，trunks=[]</li><li>vm1-vif收到不带vlan的数据包后没有向vm2-vif转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220713212741.png" alt></li></ul><p><strong>发包 带vlan 0</strong><br>带vlan 0的数据包无法进入</p><p><strong>发包 带vlan 10</strong></p><ul><li>设置vm1-vif access模式，tag=10</li><li>vm1-vif收到vlan 10的数据包转发到vm2-vif，vm2-vif处理后以原始vlan转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220713212843.png" alt></li></ul><p><strong>发包 带vlan 11</strong></p><ul><li>设置vm1-vif access模式，tag=11</li><li>vm1-vif收到vlan 11的数据包没有转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713213027.png" alt></li></ul><h4 id="native-vlan和trunks不重合"><a href="#native-vlan和trunks不重合" class="headerlink" title="native vlan和trunks不重合"></a>native vlan和trunks不重合</h4><pre><code>ovs-vsctl set Port vm1-vif vlan_mode=native-taggedovs-vsctl set Port vm2-vif vlan_mode=native-taggedovs-vsctl set Port vm1-vif trunks=[10]ovs-vsctl set Port vm1-vif tag=11ovs-vsctl set Port vm2-vif trunks=[10]ovs-vsctl set Port vm2-vif tag=11</code></pre><p><img src="/2022/07/05/ovs-port-vlan/img-20220713213656.png" alt></p><p><strong>收包 不带vlan</strong></p><ul><li>vm1发出不带vlan的数据包，vm1-vif处理后带vlan 11<br><img src="/2022/07/05/ovs-port-vlan/img-20220713213800.png" alt></li></ul><p><strong>收包 带vlan 0</strong></p><ul><li>vm1发出带vlan 0的数据包，vm1-vif处理后带vlan 11<br><img src="/2022/07/05/ovs-port-vlan/img-20220713213923.png" alt></li></ul><p><strong>收包 带vlan 10</strong></p><ul><li>vm1 发出带vlan 10的数据包，vm1-vif处理后带着原始vlan进入<br><img src="/2022/07/05/ovs-port-vlan/img-20220713214019.png" alt></li></ul><p><strong>收包 带vlan 11</strong></p><ul><li>vm1 发出带vlan 11的数据包，vm1-vif处理后带着原始vlan进入<br><img src="/2022/07/05/ovs-port-vlan/img-20220713214125.png" alt></li></ul><p><strong>发包 带vlan 12</strong></p><ul><li>vm1 发出带vlan 12的数据包，vm1-vif处理不在允许之列丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220713214218.png" alt></li></ul><p><strong>发包 不带vlan</strong></p><ul><li>vm1设置trunk模式，trunks=[]</li><li>vm1收到不带vlan的数据包，没有向vm2-vif转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220713214451.png" alt></li></ul><p><strong>发包 带vlan 0</strong><br>带vlan 0的数据包无法进入</p><p><strong>发包 带vlan 10</strong></p><ul><li>vm1设置access模式，tag=10</li><li>vm1-vif 收到带vlan 10的数据包，转发到vm2-vif，vm2-vif以原始vlan转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220713214701.png" alt></li></ul><p><strong>发包 带vlan 11</strong></p><ul><li>vm1设置access模式，tag=11</li><li>vm1-vif收到带vlan 11的数据包，转发到vm2-vif，vm2-vif以原始vlan转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220713214834.png" alt></li></ul><p><strong>发包 带vlan 12</strong></p><ul><li>vm1设置access模式，tag=12</li><li>vm1-vif收到带vlan 12的数据包，没有转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713214945.png" alt></li></ul><h3 id="native-untagged模式"><a href="#native-untagged模式" class="headerlink" title="native-untagged模式"></a>native-untagged模式</h3><p>native vlan即tag列<br>收包：收包不带vlan，则打上native vlan进入，收包带vlan且在允许之列，则进入<br>发包：发包和native vlan相同，则去掉vlan转发，否则带着原始vlan转发</p><h4 id="native-vlan和trunks重合-1"><a href="#native-vlan和trunks重合-1" class="headerlink" title="native vlan和trunks重合"></a>native vlan和trunks重合</h4><pre><code>ovs-vsctl set Port vm1-vif vlan_mode=native-untaggedovs-vsctl set Port vm2-vif vlan_mode=native-untaggedovs-vsctl set Port vm1-vif trunks=[10]ovs-vsctl set Port vm1-vif tag=10ovs-vsctl set Port vm2-vif trunks=[10]ovs-vsctl set Port vm2-vif tag=10</code></pre><p><img src="/2022/07/05/ovs-port-vlan/img-20220713215316.png" alt></p><p><strong>收包 不带vlan</strong></p><ul><li>vm1发出不带vlan的数据包，vm1-vif处理后带vlan 10<br><img src="/2022/07/05/ovs-port-vlan/img-20220713215402.png" alt></li></ul><p><strong>收包 带vlan 0</strong></p><ul><li>vm1发出带vlan 0的数据包，vm1-vif处理后带vlan 10<br><img src="/2022/07/05/ovs-port-vlan/img-20220713215454.png" alt></li></ul><p><strong>收包 带vlan 10</strong></p><ul><li>vm1 发出带vlan 10的数据包，vm1-vif处理后带原始vlan 进入<br><img src="/2022/07/05/ovs-port-vlan/img-20220713215625.png" alt></li></ul><p><strong>收包 带vlan 11</strong></p><ul><li>vm1 发出带vlan 11的数据包，vm1-vif处理后不在允许之列，丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220713215748.png" alt></li></ul><p><strong>发包 不带vlan</strong></p><ul><li>设置vm1-vif trunk模式，trunks=[]</li><li>vm1-vif收到不带vlan的数据包后不会转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713220011.png" alt></li></ul><p><strong>发包 带vlan 0</strong><br>带vlan 0的数据包无法进入</p><p><strong>发包 带vlan 10</strong></p><ul><li>设置vm1-vif access模式，tag=10</li><li>vm1-vif收到带vlan 10的数据包转发到vm2-vif,vm2-vif处理后去掉vlan转发到vm2<br><img src="/2022/07/05/ovs-port-vlan/img-20220713220151.png" alt></li></ul><p><strong>发包 带vlan 11</strong></p><ul><li>设置vm1-vif access模式，tag=11</li><li>vm1-vif收到带vlan 11的数据包不会转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713220356.png" alt></li></ul><h4 id="native-vlan和trunks不重合-1"><a href="#native-vlan和trunks不重合-1" class="headerlink" title="native vlan和trunks不重合"></a>native vlan和trunks不重合</h4><pre><code>ovs-vsctl set Port vm1-vif vlan_mode=native-untaggedovs-vsctl set Port vm2-vif vlan_mode=native-untaggedovs-vsctl set Port vm1-vif trunks=[10]ovs-vsctl set Port vm1-vif tag=11ovs-vsctl set Port vm2-vif trunks=[10]ovs-vsctl set Port vm2-vif tag=11</code></pre><p><img src="/2022/07/05/ovs-port-vlan/img-20220713220442.png" alt></p><p><strong>收包 不带vlan</strong></p><ul><li>vm1发出不带vlan的数据包，vm1-vif处理后打上vlan 11<br><img src="/2022/07/05/ovs-port-vlan/img-20220713220628.png" alt></li></ul><p><strong>收包 带vlan 0</strong></p><ul><li>vm1发出带vlan 0的数据包，vm1-vif处理后打上vlan 11<br><img src="/2022/07/05/ovs-port-vlan/img-20220713220741.png" alt></li></ul><p><strong>收包 带vlan 10</strong></p><ul><li>vm1发出带vlan 10的数据包，vm1-vif处理后带着原始vlan 进入<br><img src="/2022/07/05/ovs-port-vlan/img-20220713220829.png" alt></li></ul><p><strong>收包 带vlan 11</strong></p><ul><li>vm1发出带vlan 11的数据包，vm1-vif处理后带着原始vlan 进入<br><img src="/2022/07/05/ovs-port-vlan/img-20220713220933.png" alt></li></ul><p><strong>发包 带vlan 12</strong></p><ul><li>vm1发出带vlan 11的数据包，vm1-vif处理后不在允许范围内丢弃<br><img src="/2022/07/05/ovs-port-vlan/img-20220713221021.png" alt></li></ul><p><strong>发包 不带vlan</strong></p><ul><li>vm1-vif设置trunk模式 trunks=0</li><li>vm1-vif收到不带vlan的数据包，不会向vm2-vif转发<br><img src="/2022/07/05/ovs-port-vlan/img-20220713221252.png" alt></li></ul><p><strong>发包 带vlan 0</strong><br>带vlan 0的数据包无法进入</p><p><strong>发包 带vlan 10</strong></p><ul><li>vm1-vif设置access模式 tag=10</li><li>vm1-vif收到带vlan 10的数据包转发到vm2-vif，vm2-vif处理后带着原始vlan转发到vm2<br><img src="/2022/07/05/ovs-port-vlan/img-20220713221436.png" alt></li></ul><p><strong>发包 带vlan 11</strong></p><ul><li>vm1-vif设置access模式 tag=11</li><li>vm1-vif收到带vlan 11的数据包转发到vm2-vif，vm2-vif处理后去掉vlan转发到vm2<br><img src="/2022/07/05/ovs-port-vlan/img-20220713221610.png" alt></li></ul><p><strong>发包 带vlan 12</strong></p><ul><li>vm1-vif设置access模式 tag=12</li><li>vm1-vif收到带vlan 12的数据包不会转发到vm2-vif<br><img src="/2022/07/05/ovs-port-vlan/img-20220713221726.png" alt></li></ul><p>参考：<br>思维导插件<code>npm install hexo-simple-mindmap</code><br>ovs-tcpdump <code>https://docs.openvswitch.org/en/latest/ref/ovs-tcpdump.8/</code></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> NetWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OVS </tag>
            
            <tag> VLAN </tag>
            
            <tag> ACCESS </tag>
            
            <tag> TRUNK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win-11 安装linux子系统并使用</title>
      <link href="/2022/06/25/win11-wsl/"/>
      <url>/2022/06/25/win11-wsl/</url>
      
        <content type="html"><![CDATA[<p>参考链接：<a href="https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview" target="_blank" rel="noopener">https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview</a></p><h1 id="确认环境"><a href="#确认环境" class="headerlink" title="确认环境"></a>确认环境</h1><ul><li>确认操作系统版本<br>windows搜索 关于你的电脑 -&gt; 操作系统版本<br>操作系统版本需要大于22000</li></ul><p><img src="/2022/06/25/win11-wsl/img-20220625215308.png" alt></p><ul><li>确认开启虚拟化功能<br>windows搜索 windows功能 - 虚拟机平台<br>适用于linux的windows子系统和windows虚拟机监控程序平台也最好勾选，需要<strong>重启生效</strong>。<br><img src="/2022/06/25/win11-wsl/img-20220625215633.png" alt></li></ul><h1 id="安装wsl和ubuntu"><a href="#安装wsl和ubuntu" class="headerlink" title="安装wsl和ubuntu"></a>安装wsl和ubuntu</h1><ul><li><p>在windows应用商店搜索<code>Windows Subsystem</code>，获取并且安装<br>也可以使用其他方式下载wsl并安装。<br><img src="/2022/06/25/win11-wsl/img-20220625220014.png" alt></p></li><li><p>使用wsl2<br>执行<code>wsl --set-default-version 2</code></p></li><li><p>在windows应用商店搜索<code>ubuntu</code>，安装linux发行版<br>也可以自己选择其他发行版安装。<br><img src="/2022/06/25/win11-wsl/img-20220625220129.png" alt></p></li><li><p>最终可以使用<br><img src="/2022/06/25/win11-wsl/img-20220625221705.png" alt></p></li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>列出已安装wsl信息<br><code>wsl -l -v</code></p><p>启动wsl<br><code>wsl -d &lt;自定义的系统名&gt;</code></p><p>设置wsl版本为2<br><code>wsl --set-version &lt;自定义的系统名&gt; 2</code></p><p>关闭系统<br><code>wsl --shutdown -n &lt;自定义的系统名&gt;</code></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li>linux发行版启动时遇到报错<code>占位程序接收到错误数据</code><br>通过执行<code>netsh winsock reset</code>解决</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言基础</title>
      <link href="/2022/06/05/hello-go/"/>
      <url>/2022/06/05/hello-go/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言基础语法介绍"><a href="#Go语言基础语法介绍" class="headerlink" title="Go语言基础语法介绍"></a>Go语言基础语法介绍</h2><ul><li><p>Google开源</p></li><li><p>编译型语言</p></li></ul><p>特点：</p><ul><li><p>语法简洁</p></li><li><p>开发效率高</p></li><li><p>执行性能好</p></li></ul><p>参考:<a href="http://www.liwenzhou.com" target="_blank" rel="noopener">www.liwenzhou.com</a>  <a href="https://go.dev/tour/welcome/1" target="_blank" rel="noopener">https://go.dev/tour/welcome/1</a></p><h2 id="Go开发环境搭建"><a href="#Go开发环境搭建" class="headerlink" title="Go开发环境搭建"></a>Go开发环境搭建</h2><p>Go开发包镜像地址：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a></p><p>安装好后，cmd下运行<code>go version</code>显示版本号</p><h2 id="go语法"><a href="#go语法" class="headerlink" title="go语法"></a>go语法</h2><h3 id="包、变量、函数"><a href="#包、变量、函数" class="headerlink" title="包、变量、函数"></a>包、变量、函数</h3><pre><code>推荐import package方式import (    &quot;fmt&quot;    &quot;math&quot;)</code></pre><p><strong>函数</strong></p><p>func 函数名(参数名 类型,…) 返回值… {</p><p>}</p><ul><li><p>多个参数同一类型时，支持简写<code>(x, y int)</code></p></li><li><p>支持多个返回值时 声明为<code>func swap(x, y string) (string, string)</code>   返回为 <code>return x, y</code></p></li><li><p>支持return named return values   声明为<code>func test(sum int)(x, y int)</code>   返回为 <code>return</code></p></li></ul><p><strong>变量</strong></p><ul><li><p>var 变量名… 类型   // 声明</p></li><li><p><code>var x, y int = 1, 2</code> // 声明加初始化</p></li><li><p><code>x := 1</code>            // 短变量声明，类型推导出x是什么类型</p></li></ul><p><strong>基本类型</strong></p><pre><code>boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // alias for uint8rune // alias for int32     // represents a Unicode code pointfloat32 float64complex64 complex128zero values：0 for numeric types,false for the boolean type, and&quot;&quot; (the empty string) for strings.nil for other type</code></pre><p><strong>类型转换</strong></p><p><code>T(v)</code></p><p><strong>常量</strong></p><p><code>const 变量 = 值</code></p><ul><li>不能使用短变量声明法</li></ul><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>for</strong></p><pre><code>for init statment; condition statement; post statement {}</code></pre><ul><li><p>初始和结束执行的语句可以省略(保留分号)</p></li><li><p>语句只有condition，效果为像使用while一样(没有分号)</p></li><li><p>语句连condition都没有(用于死循环)</p></li></ul><p><strong>if</strong></p><pre><code>if condition {}</code></pre><ul><li><p>没有小括号，但是{}是必须的</p></li><li><p>变形 <code>if init statement; condition stament {}</code>(init statement声明的短变量作用域在if else块内)</p></li></ul><p><strong>switch</strong></p><pre><code>switch init statement;condition{    case 值1：    case 值2}</code></pre><ul><li><p>go自动在每个case后break</p></li><li><p>switch case的条件不必是const的，也不一定是integer</p></li><li><p>switch语句也可以带短变量声明语句，也可以省略condition(等于switch true)</p></li></ul><p><strong>defer</strong></p><pre><code>func test() {    fmt.Println(&quot;123&quot;)}func main() {    defer fmt.Println(&quot;world&quot;)    fmt.Println(&quot;hello&quot;)    test()}</code></pre><ul><li><p>defer语句会立即求值，但是推迟到函数返回之前执行。</p></li><li><p>多个defer语句会压栈，直到函数返回时，多个defer会按出栈顺序调用</p></li></ul><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p><strong>pointer</strong></p><p><code>i= 42</code></p><p><code>p := &amp;i</code></p><ul><li>默认初始化为nil，没有指数算术</li></ul><p><strong>struct</strong></p><pre><code>type Vertex struct {    X int    Y int}func main() {    v := Vertex{1, 2}    p := &amp;v    p.X = 666    fmt.Println(v)}</code></pre><ul><li>可以使用v.X 也可以使用指针p.X访问成员</li></ul><p><strong>array</strong></p><pre><code>var a [2]stringa[0] = &quot;Hello&quot;a[1] = &quot;World&quot;fmt.Println(a)</code></pre><ul><li>array是值，数组长度固定</li></ul><p><strong>slice</strong></p><pre><code>primes := [6]int{2, 3, 5, 7, 11, 13}var s []int = primes[:4]  //切片fmt.Println(s)</code></pre><ul><li><p>切片是引用，切片底层指向数组，长度可扩容</p></li><li><p>切片<code>a[low:high];</code>省略low为0，省略high为切片的len</p></li><li><p>make 构造，<code>make([]int, len, cap)</code></p></li><li><p>切片元素为切片</p></li><li><p>append 可以添加一个元素、多个元素、一个切片。当切片容量不足，则新创建一个大数组，切片指向新数组</p></li></ul><p><strong>range</strong></p><ul><li><p>range 数组；slice；返回 inedx, value</p></li><li><p>range map；返回 key, value</p></li><li><p>匿名变量 <code>_</code> ，接收不使用的值</p></li></ul><p><strong>map</strong></p><ul><li><p>删除元素  <code>delete(map1, key)</code></p></li><li><p>测试key值是否存在 <code>value， ok = map1[key]</code></p></li></ul><p><strong>function</strong></p><p><code>func 函数名(参数) 返回值 {}</code></p><ul><li><p>函数可以作为参数，也可以作为返回值</p></li><li><p>函数闭包：闭包是一个函数值，它从其主体外部引用变量。该函数可以访问并分配给引用的变量。函数是绑定到变量的</p></li></ul><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><p><strong>method</strong></p><p><code>func (receiver) 函数名(参数) 返回值 {}</code></p><ul><li><p>作用于特定的receiver的函数</p></li><li><p>声明method和reveiver必须在同一个package</p></li><li><p>特定的receiver可以不是struct，可以是基本数据类型。</p><p>指针receiver 和 值receiver；指针receiver可以修改值，(传参无需关心传的是指针还是值)(函数则不行，函数必须要确定传参类型匹配)</p></li></ul><p><strong>interface</strong></p><pre><code>type T struct {    S string}type I interface {    Abs() float64}func (t T) Abs() { // 类型通过实现其method来实现接口    fmt.Println(t.S)}var i I = T{&quot;hello&quot;}i.M()</code></pre><ul><li><p>接口值可以视为(value, type)，在接口值上调用方法会在其基础类型上执行相同名称的方法。</p></li><li><p><code>var i I</code>；一个空的接口值，其value和type都是nil，调用会产生运行时错误</p></li><li><p><code>var i interface{}</code>；一个空接口，可以保存任何类型的值</p></li></ul><p><code>s, ok := i.(string)</code>； 判断接口是否含有类型string</p><ul><li><p>fmt就是其他都实现了String接口</p></li><li><p>go中的error是其他实现了Error接口</p></li></ul><pre><code>type Stringer interface {    String() string}type error interface {    Error() string}</code></pre><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p><strong>goroutines</strong></p><ul><li>协程，Go运行时管理的轻量级线程，goroutines运行在相同的地址空间，所以对共享内存的访问必须同步，可以借助sync包</li></ul><p><strong>channels</strong></p><pre><code>ch &lt;- v    // 将v值发送到通道chv := &lt;-ch  // 从通道ch接收，并给v赋值数据按照箭头方向流动// 使用前必须创建ch := make(chan int)</code></pre><ul><li><p>channel有类型，可以发送和接收 ，运算符&lt;-</p></li><li><p>默认情况下，无缓冲的channel，发送和接收是阻塞的，这允许在没有显式锁或条件变量的情况下进行同步</p></li><li><p>有缓冲的channel  <code>make(chan int, 100)</code>, 可以异步，当缓冲区满时再写入才会阻塞，缓冲区空时读取才会阻塞</p></li><li><p>通道可以close，可以通过ok测试 <code>v, ok := &lt;- ch</code>，只有发送者可以关闭通道，在关闭的通道里发送会panic，对于for range通道运算，需要主动close来告知接收者通道没有值了</p></li></ul><p><strong>select</strong></p><ul><li><p>select 语句让gotroutine等待多个通信操作， select阻塞直到它的一个case可以运行，如果都准备好了，它随机运行一个。</p></li><li><p>select 可以有default语句，当没有case准备好时，就执行default语句</p></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, Hexo</title>
      <link href="/2020/01/14/hexo-new/"/>
      <url>/2020/01/14/hexo-new/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hexo是本次新挖掘出来的搭建网站的快速工具，容易上手，且样式好看。</p></blockquote><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>一直想要一个永久的域名，但是在学生时代经费紧张，就只能先这么凑合了。偶然有一次看到了Hexo + Github搭建个人网站的例子，Hexo是一款强大的产品，可以快速的生成页面。我也有尝试另外一款是wordpress，但是我本地测试后还有很多不易用的感受，而且我也不是专业的前端程序员，而Hexo可以根据网上的教程快速的搭建成自己舒服的样子，所以就被我pick。今天正式启用此站点，Hello Hexo！</p><h2 id="2020-6-26"><a href="#2020-6-26" class="headerlink" title="2020.6.26"></a>2020.6.26</h2><p>一次偶然的机会看到百度云可以1元得到一个域名和一个虚拟主机资源，所以产生了<code>www.yteng3456.xyz</code>，后来我也在这个域名上部署了php搭建的个人页面以及在复习专业课时总结的一些文章，但是后面时间到了域名失效了，如果要用还得重新备案；虚拟主机的资源也失效了，为了折腾，就把写的文章搬到了Hexo+Github去，就当是体验了一把个人网站上云。</p><h2 id="2021-06-30"><a href="#2021-06-30" class="headerlink" title="2021.06.30"></a>2021.06.30</h2><p>hexo 文章插图技巧<br>1.站点的_config.yml 的post_asset_folder: false改为true<br>2.在新建文章的时候<code>hexo new hello</code>就会在文章下生成同名文件夹，在文件夹中放图片，在文章中引用即可。</p><pre><code>![](1.png)</code></pre><p>hexo源码等保留到了github，换了电脑或者笔记本重装系统后需要重新部署环境</p><ul><li>安装git，配置git账号信息，ssh key</li><li>安装nodejs</li><li>安装hexo <code>npm install -g hexo-cli</code></li><li>安装git部署插件 <code>npm install hexo-deployer-git --save</code></li><li>安装图片路径转换插件 <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></li></ul><p><code>hexo d</code>失败，报错：<code>typeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object</code><br>原因：nodejs版本过高，和hexo版本不匹配<br>解决办法：切换nodejs为低版本</p><h2 id="2021-08-15"><a href="#2021-08-15" class="headerlink" title="2021.08.15"></a>2021.08.15</h2><p>hexo文章编写技巧</p><p><code>&lt;!--more--&gt;</code>该标签前面可以写文章摘要</p><p><code>&lt;center&gt;&lt;center/&gt;</code> 该标签可以把摘要居中</p><p><code>&lt;br/&gt;</code>该标签可以插入一个换行</p><p>可以不用<code>![]</code>来插入图片，可以使用<code>&lt;img src=&#39;&#39; width=&#39;20&#39; height=&#39;20&gt;</code>来插入图片</p><h2 id="2022-05-22"><a href="#2022-05-22" class="headerlink" title="2022.05.22"></a>2022.05.22</h2><p>参考别人的主题进行了一次改版，参考网站：<code>https://godweiyang.com/</code><br>Matery主题美化参考：<code>https://blog.csdn.net/kuashijidexibao/article/details/112971657</code><br>为什么要改版？<br>因为之前的风格看的有些厌倦，不能让我很好的坚持写博客，不如换一个风格。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>markdown文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td></td></tr><tr><td>author</td><td>根 _config.yml 中的 author</td><td></td></tr><tr><td>img</td><td>featureImages 中的某个值</td><td>文章特征图，推荐使用图床</td></tr><tr><td>top</td><td>true</td><td>推荐文章(文章是否置顶)，如果top为true，则会作为首页推荐文章</td></tr><tr><td>cover</td><td>false</td><td>表示该文章是否需要加入到首页轮播封面</td></tr><tr><td>coverImg</td><td>无</td><td>表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置</td></tr><tr><td>toc</td><td>true</td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td>false</td><td>是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
