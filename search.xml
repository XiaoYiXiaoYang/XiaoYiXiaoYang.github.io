<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go语言基础</title>
      <link href="/2022/06/05/hello-go/"/>
      <url>/2022/06/05/hello-go/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言基础语法介绍"><a href="#Go语言基础语法介绍" class="headerlink" title="Go语言基础语法介绍"></a>Go语言基础语法介绍</h2><ul><li><p>Google开源</p></li><li><p>编译型语言</p></li></ul><p>特点：</p><ul><li><p>语法简洁</p></li><li><p>开发效率高</p></li><li><p>执行性能好</p></li></ul><p>参考:<a href="http://www.liwenzhou.com" target="_blank" rel="noopener">www.liwenzhou.com</a>  <a href="https://go.dev/tour/welcome/1" target="_blank" rel="noopener">https://go.dev/tour/welcome/1</a></p><h2 id="Go开发环境搭建"><a href="#Go开发环境搭建" class="headerlink" title="Go开发环境搭建"></a>Go开发环境搭建</h2><p>Go开发包镜像地址：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a></p><p>安装好后，cmd下运行<code>go version</code>显示版本号</p><h2 id="go语法"><a href="#go语法" class="headerlink" title="go语法"></a>go语法</h2><h3 id="包、变量、函数"><a href="#包、变量、函数" class="headerlink" title="包、变量、函数"></a>包、变量、函数</h3><pre><code>推荐import package方式import (    &quot;fmt&quot;    &quot;math&quot;)</code></pre><p><strong>函数</strong></p><p>func 函数名(参数名 类型,…) 返回值… {</p><p>}</p><ul><li><p>多个参数同一类型时，支持简写<code>(x, y int)</code></p></li><li><p>支持多个返回值时 声明为<code>func swap(x, y string) (string, string)</code>   返回为 <code>return x, y</code></p></li><li><p>支持return named return values   声明为<code>func test(sum int)(x, y int)</code>   返回为 <code>return</code></p></li></ul><p><strong>变量</strong></p><ul><li><p>var 变量名… 类型   // 声明</p></li><li><p><code>var x, y int = 1, 2</code> // 声明加初始化</p></li><li><p><code>x := 1</code>            // 短变量声明，类型推导出x是什么类型</p></li></ul><p><strong>基本类型</strong></p><pre><code>boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // alias for uint8rune // alias for int32     // represents a Unicode code pointfloat32 float64complex64 complex128zero values：0 for numeric types,false for the boolean type, and&quot;&quot; (the empty string) for strings.nil for other type</code></pre><p><strong>类型转换</strong></p><p><code>T(v)</code></p><p><strong>常量</strong></p><p><code>const 变量 = 值</code></p><ul><li>不能使用短变量声明法</li></ul><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>for</strong></p><pre><code>for init statment; condition statement; post statement {}</code></pre><ul><li><p>初始和结束执行的语句可以省略(保留分号)</p></li><li><p>语句只有condition，效果为像使用while一样(没有分号)</p></li><li><p>语句连condition都没有(用于死循环)</p></li></ul><p><strong>if</strong></p><pre><code>if condition {}</code></pre><ul><li><p>没有小括号，但是{}是必须的</p></li><li><p>变形 <code>if init statement; condition stament {}</code>(init statement声明的短变量作用域在if else块内)</p></li></ul><p><strong>switch</strong></p><pre><code>switch init statement;condition{    case 值1：    case 值2}</code></pre><ul><li><p>go自动在每个case后break</p></li><li><p>switch case的条件不必是const的，也不一定是integer</p></li><li><p>switch语句也可以带短变量声明语句，也可以省略condition(等于switch true)</p></li></ul><p><strong>defer</strong></p><pre><code>func test() {    fmt.Println(&quot;123&quot;)}func main() {    defer fmt.Println(&quot;world&quot;)    fmt.Println(&quot;hello&quot;)    test()}</code></pre><ul><li><p>defer语句会立即求值，但是推迟到函数返回之前执行。</p></li><li><p>多个defer语句会压栈，直到函数返回时，多个defer会按出栈顺序调用</p></li></ul><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p><strong>pointer</strong></p><p><code>i= 42</code></p><p><code>p := &amp;i</code></p><ul><li>默认初始化为nil，没有指数算术</li></ul><p><strong>struct</strong></p><pre><code>type Vertex struct {    X int    Y int}func main() {    v := Vertex{1, 2}    p := &amp;v    p.X = 666    fmt.Println(v)}</code></pre><ul><li>可以使用v.X 也可以使用指针p.X访问成员</li></ul><p><strong>array</strong></p><pre><code>var a [2]stringa[0] = &quot;Hello&quot;a[1] = &quot;World&quot;fmt.Println(a)</code></pre><ul><li>array是值，数组长度固定</li></ul><p><strong>slice</strong></p><pre><code>primes := [6]int{2, 3, 5, 7, 11, 13}var s []int = primes[:4]  //切片fmt.Println(s)</code></pre><ul><li><p>切片是引用，切片底层指向数组，长度可扩容</p></li><li><p>切片<code>a[low:high];</code>省略low为0，省略high为切片的len</p></li><li><p>make 构造，<code>make([]int, len, cap)</code></p></li><li><p>切片元素为切片</p></li><li><p>append 可以添加一个元素、多个元素、一个切片。当切片容量不足，则新创建一个大数组，切片指向新数组</p></li></ul><p><strong>range</strong></p><ul><li><p>range 数组；slice；返回 inedx, value</p></li><li><p>range map；返回 key, value</p></li><li><p>匿名变量 <code>_</code> ，接收不使用的值</p></li></ul><p><strong>map</strong></p><ul><li><p>删除元素  <code>delete(map1, key)</code></p></li><li><p>测试key值是否存在 <code>value， ok = map1[key]</code></p></li></ul><p><strong>function</strong></p><p><code>func 函数名(参数) 返回值 {}</code></p><ul><li><p>函数可以作为参数，也可以作为返回值</p></li><li><p>函数闭包：闭包是一个函数值，它从其主体外部引用变量。该函数可以访问并分配给引用的变量。函数是绑定到变量的</p></li></ul><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><p><strong>method</strong></p><p><code>func (receiver) 函数名(参数) 返回值 {}</code></p><ul><li><p>作用于特定的receiver的函数</p></li><li><p>声明method和reveiver必须在同一个package</p></li><li><p>特定的receiver可以不是struct，可以是基本数据类型。</p><p>指针receiver 和 值receiver；指针receiver可以修改值，(传参无需关心传的是指针还是值)(函数则不行，函数必须要确定传参类型匹配)</p></li></ul><p><strong>interface</strong></p><pre><code>type T struct {    S string}type I interface {    Abs() float64}func (t T) Abs() { // 类型通过实现其method来实现接口    fmt.Println(t.S)}var i I = T{&quot;hello&quot;}i.M()</code></pre><ul><li><p>接口值可以视为(value, type)，在接口值上调用方法会在其基础类型上执行相同名称的方法。</p></li><li><p><code>var i I</code>；一个空的接口值，其value和type都是nil，调用会产生运行时错误</p></li><li><p><code>var i interface{}</code>；一个空接口，可以保存任何类型的值</p></li></ul><p><code>s, ok := i.(string)</code>； 判断接口是否含有类型string</p><ul><li><p>fmt就是其他都实现了String接口</p></li><li><p>go中的error是其他实现了Error接口</p></li></ul><pre><code>type Stringer interface {    String() string}type error interface {    Error() string}</code></pre><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p><strong>goroutines</strong></p><ul><li>协程，Go运行时管理的轻量级线程，goroutines运行在相同的地址空间，所以对共享内存的访问必须同步，可以借助sync包</li></ul><p><strong>channels</strong></p><pre><code>ch &lt;- v    // 将v值发送到通道chv := &lt;-ch  // 从通道ch接收，并给v赋值数据按照箭头方向流动// 使用前必须创建ch := make(chan int)</code></pre><ul><li><p>channel有类型，可以发送和接收 ，运算符&lt;-</p></li><li><p>默认情况下，无缓冲的channel，发送和接收是阻塞的，这允许在没有显式锁或条件变量的情况下进行同步</p></li><li><p>有缓冲的channel  <code>make(chan int, 100)</code>, 可以异步，当缓冲区满时再写入才会阻塞，缓冲区空时读取才会阻塞</p></li><li><p>通道可以close，可以通过ok测试 <code>v, ok := &lt;- ch</code>，只有发送者可以关闭通道，在关闭的通道里发送会panic，对于for range通道运算，需要主动close来告知接收者通道没有值了</p></li></ul><p><strong>select</strong></p><ul><li><p>select 语句让gotroutine等待多个通信操作， select阻塞直到它的一个case可以运行，如果都准备好了，它随机运行一个。</p></li><li><p>select 可以有default语句，当没有case准备好时，就执行default语句</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, Hexo</title>
      <link href="/2020/01/14/hexo-new/"/>
      <url>/2020/01/14/hexo-new/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hexo是本次新挖掘出来的搭建网站的快速工具，容易上手，且样式好看。</p></blockquote><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>一直想要一个永久的域名，但是在学生时代经费紧张，就只能先这么凑合了。偶然有一次看到了Hexo + Github搭建个人网站的例子，Hexo是一款强大的产品，可以快速的生成页面。我也有尝试另外一款是wordpress，但是我本地测试后还有很多不易用的感受，而且我也不是专业的前端程序员，而Hexo可以根据网上的教程快速的搭建成自己舒服的样子，所以就被我pick。今天正式启用此站点，Hello Hexo！</p><h2 id="2020-6-26"><a href="#2020-6-26" class="headerlink" title="2020.6.26"></a>2020.6.26</h2><p>一次偶然的机会看到百度云可以1元得到一个域名和一个虚拟主机资源，所以产生了<code>www.yteng3456.xyz</code>，后来我也在这个域名上部署了php搭建的个人页面以及在复习专业课时总结的一些文章，但是后面时间到了域名失效了，如果要用还得重新备案；虚拟主机的资源也失效了，为了折腾，就把写的文章搬到了Hexo+Github去，就当是体验了一把个人网站上云。</p><h2 id="2021-06-30"><a href="#2021-06-30" class="headerlink" title="2021.06.30"></a>2021.06.30</h2><p>hexo 文章插图技巧<br>1.站点的_config.yml 的post_asset_folder: false改为true<br>2.在新建文章的时候<code>hexo new hello</code>就会在文章下生成同名文件夹，在文件夹中放图片，在文章中引用即可。</p><pre><code>![](1.png)</code></pre><p>hexo源码等保留到了github，换了电脑或者笔记本重装系统后需要重新部署环境</p><ul><li>安装git，配置git账号信息，ssh key</li><li>安装nodejs</li><li>安装hexo <code>npm install -g hexo-cli</code></li><li>安装git部署插件 <code>npm install hexo-deployer-git --save</code></li><li>安装图片路径转换插件 <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></li></ul><p><code>hexo d</code>失败，报错：<code>typeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object</code><br>原因：nodejs版本过高，和hexo版本不匹配<br>解决办法：切换nodejs为低版本</p><h2 id="2021-08-15"><a href="#2021-08-15" class="headerlink" title="2021.08.15"></a>2021.08.15</h2><p>hexo文章编写技巧</p><p><code>&lt;!--more--&gt;</code>该标签前面可以写文章摘要</p><p><code>&lt;center&gt;&lt;center/&gt;</code> 该标签可以把摘要居中</p><p><code>&lt;br/&gt;</code>该标签可以插入一个换行</p><p>可以不用<code>![]</code>来插入图片，可以使用<code>&lt;img src=&#39;&#39; width=&#39;20&#39; height=&#39;20&gt;</code>来插入图片</p><h2 id="2022-05-22"><a href="#2022-05-22" class="headerlink" title="2022.05.22"></a>2022.05.22</h2><p>参考别人的主题进行了一次改版，参考网站：<code>https://godweiyang.com/</code><br>Matery主题美化参考：<code>https://blog.csdn.net/kuashijidexibao/article/details/112971657</code><br>为什么要改版？<br>因为之前的风格看的有些厌倦，不能让我很好的坚持写博客，不如换一个风格。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>markdown文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td></td></tr><tr><td>author</td><td>根 _config.yml 中的 author</td><td></td></tr><tr><td>img</td><td>featureImages 中的某个值</td><td>文章特征图，推荐使用图床</td></tr><tr><td>top</td><td>true</td><td>推荐文章(文章是否置顶)，如果top为true，则会作为首页推荐文章</td></tr><tr><td>cover</td><td>false</td><td>表示该文章是否需要加入到首页轮播封面</td></tr><tr><td>coverImg</td><td>无</td><td>表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置</td></tr><tr><td>toc</td><td>true</td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td>false</td><td>是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
