---
title: C++基础（类和对象）
date: 2019-12-08 15:23:51
tags: [C++]
categories: [学习笔记]
---

 终于复习到了面向对象的核心内容

<!--more-->

#### 类和对象
*从前到后一点一点总结*
类和对象的相关名词：**抽象、封装、继承、多态**
抽象的结果：共同的属性。共同的行为
封装：把抽象的数据和行为封装成类

类成员的访问控制
public：在类外只能访问类的公有成员
protected：和private相似
private：只能被奔雷的成员函数访问，来自类外部的任何访问都是非法的；（如果私有成员紧接着类名称，则关键字private可以省略）

在类中，对于未指定的访问控制属性的成员，其访问控制属性为私有类型（private）
在结构体中，对于未指定的访问控制属性的成员，其访问控制属性为公有类型（public）



**类的静态数据成员和静态函数成员**
静态数据成员：某个属性为整个类所有，不属于任何一个具体的对象(具有静态生存期)

```
class Point{
public:
	Point(){count++;}
private:
	static int count;  //静态数据成员声明，
};
int Point::count =0;  //静态数据成员定义和初始化，使用类名限定
```

**定义和初始化在类外完成，要利用类名引用**

静态函数成员：使用static声明的函数成员

*静态函数成员可以直接访问该类的静态数据成员和静态函数成员，
而访问非静态函数成员和非静态数据成员，必须通过对象名*

```c++
class Point{
public:
	Point(){count++;}
	static void showCount(){cout<<count<<endl;}  //静态函数成员
private:
	static int count;  //静态数据成员声明，
};
int Point::count =0;  //静态数据成员定义和初始化，使用类名限定
int main(){
	Point::showCount();  //输出对象个数
}
```



**类的友元**
友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制

友元函数(一个普通函数或者类的成员函数可以访问另一个类中的函数)

```c++
class Point{
	friend float dist(Point &p1,Point &p2);  //友元函数声明
};
	float dist(Point &p1,Point &p2){//友元函数实现
	double x = p1.x-p2.x;
	}
```
从代码中看出友元函数是个普通函数，同时他也可以是其他类的成员函数

友元类（若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员）

```c++
class B{
	...
	friend class A;  //声明A为B类的友元类
}
```
划重点
友元关系是不能传递的；(A是B的友元，C是A的友元 ----没有C是B的)
友元关系是单向的；（A类是B类的友元类，A的成员函数可以访问B的私有和保护数据，但是B的成员函数不能访问A的私有和保护数据）
友元关系是不被继承的；（A类是B类的友元，则A类的派生类不会自动成为B类的友元类）



**常对象**（用const修饰的对象）
他的数据成员值在对象的整个生存期内不能被改变，常对象必须进行初始化，而且不能被更新

```c++
class A{
	A(){}
};
const A a();   //a是常对象，不能被更新
```
如果通过对象名访问其数据成员，由于常对象的数据成员被视为常量，所以不能重新赋值；如果通过成员函数改变数据成员的值，常对象规定不能通过常对象调用普通的成员函数；但是可以调用常成员函数



**常成员函数**（const修饰的成员函数）
常对象只能调用常成员函数
普通对象可以调用常成员函数，调用期间视为常对象
关键字const可以用于对重载函数的区分

```c++
void print();
void print() const;有效重载
```



**常数据成员**（使用const声明的数据成员）
任何函数都不能对该成员赋值，构造函数对该成员进行初始化，只能通过初始化列表

```c++
class A{
public:
	A(int i);
private:
	const int a;
}；
A::A(int i):a(i);  //常数据成员只能通过初始化列表来获得初值
```



**常引用**（声明引用时用const修饰，常引用引用的对象不能被更新）
非const的引用只能绑定到普通对象
const的引用能绑定到普通对象，也能绑定到常对象，绑定后则把该对象当做常对象



**内联成员函数**
将函数体直接放在类体内，称为隐式声明
函数体放在类体外，加上inline关键字，称为显式声明



**继承与派生**（新的类熊原有的类那里得到已有的特性）
原有的类称为基类或父类，新的类称为派生类或子类，Ce+允许多继承和单继承
1.吸收基类成员，2.改造基类成员（基类成员的访问控制，对基类数据或函数成员的覆盖或隐藏），3.添加新的成员

public继承:基类的公有成员和保护成员在派生类中不变，而基类的私有成员在派生类中不可直接访问；
protected继承:基类的公有成员和保护成员以保护成员身份出现在派生类中，而基类的私有成员不可直接访问；
private继承:基类的公有成员和保护成员以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可直接访问；



**类型兼容规则**（在任何需要基类对象的地方，都可以使用公有派生类的对象来替代）
派生类的对象可以隐含转换为基类对象
派生类的对象可以初始化基类的引用
派生类的对象可以隐含转换为基类的指针



**派生类构造函数**
1.调用基类构造函数，调用顺序按照他们被继承时声明的顺序
2.对派生类新增的成员对象进行初始化，调用顺序按照他们在类中声明的顺序
3.指向派生类的构造函数体中的内容



**派生类析构函数**
1.首先执行析构函数的函数体，
2.然后对派生类新增的类类型的成员对象进行清理，
3.最后对所有从基类继承来的成员进行清理



**派生类成员的标识访问**
隐藏规则：如果外层和内层声明了相同的标识符，那么外层标识符在内层不可见，
如果派生类中声明了与基类成员函数同名的新函数，及时函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏。



**多继承同名隐藏：**
如果派生类的多个基类拥有同名函数成员，派生类又新增这样的同名函数成员，这种情况下，派生类函数成员将隐藏所有基类的同名成员，这时使用“对象名.成员名”或者“对象指针->成员名”可以唯一标识派生类的新增成员；
如果派生类没有新增同名成员，“对象名.成员名”或者“对象指针->成员名”就没有办法唯一标识成员，就需要根据基类名和作用域分辨符来标识成员；

如果某个派生类的部分或全部直接基类是从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员拥有相同的名称，因此派生类中也会产生同名现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用**直接基类**来规定。



**虚基类**
如果某个派生类的部分或全部直接基类是从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员拥有相同的名称，因此派生类中也会产生多个副本，可以使用作用域分蝙蝠来唯一标识，也可以将共同基类设置为虚基类，这时候从不同路径继承来的同名数据成员在内存中就只有一个副本，同一个函数名也只有一个映射
class 派生类名:virtual 继承方式 基类名

创建派生类对象后，通过成员名称就可以访问该类的成员

虚基类及其派生类构造函数
虚基类有自己的构造函数，在整个继承关系中，所有直接或间接继承虚基类的所有派生类，都必须在构造函数初始化列表中列出对虚基类的初始化，

当多个派生类对虚基类进行初始化，C++采**用最远派生类构造**，即创建一个对象时，如果这个对象中含有从虚基类继承来的成员，则虚基类的成员由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的，而且，只有最远派生类的构造函数会调用虚基类的构造函数，该派生类的其他基类对虚基类构造函数的调用被自动忽略



**多态**（消息被不同对象接收时导致不同的行为）
编译时的多态：编译过程中确定了同名操作的具体对象
运行时的多态：程序运行过程中才动态确定操作的具体对象
绑定：就是把一条消息和一个对象绑定的过程
静态绑定：绑定工作编译连接阶段完成
动态绑定：绑定工作在程序运行阶段完成



**运算符重载**（对已有运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为）
不能重载的操作符，类属关系运算符.   成员指针运算符->   作用域分辨符::  三目运算符？

重载为类的成员函数时，函数的参数个数比原来少一个，第一个操作数会被作为函数调用的目的对象，因此无需出现在参数表中，函数体可以直接访问第一个操作数的成员
重载为类的非成员函数时，参数个数与原操作数个数相同，运算符的所有操作数必须显式通过参数传递

前置单目运算符重载（类名 &operate++()）
后置单目运算符重载（类名 &operate++(int)）

前置单目运算符重载（friend 类名 operate++()）
后置单目运算符重载（friend 类名 operate++(int)）



**虚函数**（用virtual限定的成员函数，关键字virtual只能出现在类定义中的函数原型声明中，不能在成员函数实现的时候）
运行过程中的多态需要满足的3个条件
1.满足类型兼容规则
2.要声明虚函数
3.由成员函数来调用或者是通过指针、引用来访问虚函数

系统遵循以下对着判断派生类的一个函数成员是不是虚函数
该函数是否与基类的虚函数有相同的名称
该函数是否与基类的虚函数有相同的参数个数及相同的对应参数类型
该函数是否与基类的虚函数有相同的返回值或者满足赋值兼容规则的指针、引用型的返回值

派生类覆盖基类的成员函数时，可以使用virtual关键字，也可以不使用

如果派生类需要修改基类的行为，就应该在基类中将相应的函数声明为虚函数。而基类中声明的非虚函数，通常代表那些不希望被派生类改变的功能，也是不能实现多态的。一般不要重写继承而来的非虚函数（不强制），因为那会导致通过基类指针和派生类的指针或对象调用同名函数时，产生不同的结果，从而引起混乱。

虚析构函数（不能声明虚构造函数，但是可以声明虚析构函数）
如果一个类的析构函数时虚函数，那么由他派生来的所有子类的析构函数也是虚析构函数，在使用指针时就可以动态绑定，实现运行时的多态，保证使用基类类型的指针就能够调用适当的析构函数针对不同的对象进行清理工作



**纯虚函数**
virtual 函数类型 函数名(参数表) = 0；   //声明为纯虚函数之后，基类可以不再给出函数的实现部分，即使给出实现，也必须由派生类覆盖，否则无法进行实例化。
如果将析构函数声明为纯虚函数，则必须给出实现。

抽象类（带有纯虚函数的类）
抽象类声明了一个类族派生类的共同接口，而接口的具体实现，由派生类自己定义。
如果派生类给出所有纯虚函数的实现，这个派生类就可以定义自己的对象；如果派生类没有给出全部纯虚函数的实现，这时的派生类仍然是一个抽象类。

抽象类不能实例化，但是可以定义一个抽象类的指针，通过指针或引用，就可以指向并访问派生类的对象，进而访问派生类的成员。



------------

*2019-03-13 20:55:40 星期三
萧逸小杨*