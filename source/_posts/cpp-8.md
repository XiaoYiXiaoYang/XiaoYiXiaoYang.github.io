---
title: C++ Primer（第二章  变量和基本类型）
date: 2019-12-14 22:31:58
tags: [C++ Primer]
categories: [学习笔记]
---

 虽然叫基础，但是很多内容还是第一次学

<!--more-->



#### 第一章 开始

cerr   错误
clog   程序运行时一般性信息

```
＜＜运算符   左右接受两个运算对象，输出语句使用两个＜＜   ，此运算符返回其左侧的运算对象，则第一个运算符的结果作为第二个运算符的左侧运算对象
```

```
>>  返回其左侧对象，所以也可以连着几个>>
```

```
单行注释以//开始，以换行结束
多行注释/**/      但是不能嵌套
```

打印字符串是一个字符串字面值常量
endl 是个操作符的特殊值，作用结束当前行，并将与设备关联的缓冲区中的内容刷到设备中

读取不定的输入数据，
While(cin>>value)  读取数据直到遇到文件尾，或者无效输入(输入非整数)   Cin返回对象状态无效

＝＝相等运算符号
()运算符  调用函数
文件重定向 ...

#### 第二章 变量和基本类型

2.1基本内置类型
算术类型
类型转换
字面值常量

a.算术类型
1字节由8比特组成，1个字由32位或者64位比特组成，由机器而定
如果位置736424处的对象类型是float，且机器中的float以32比特存储，那么我们就能知道这个对象的内容占满了整个字

带符号类型和无符号类型
char          
signed char    -128-127
unsigned char  0-255

char在一些机器上是有符号的，在另一些机器上又是无符号的

b.类型转换
非布尔型赋值给布尔类型，非0为true，为0则为false
布尔值赋值给非布尔类型，true为1，false为0，
给无符号数一个超出范围的值时，结果是对无符号类型表示数值总数取模后的余数，例unsigned char a = 257; //则其值为257 % 256 =1
给带符号的类型一个超出范围的表示时，结果是未定义的，程序可能继续工作、可能崩溃，也可能生成垃圾数据

当算术表达式中既有无符号数又有有符号数时，有符号数会转换为无符号数。

```
unsigned u=10;
int i=-42;
cout<<u+i<<endl;   //-42+10=-32  负数取模得4294967264
//假设32位，2^32=4 294 967 296，减去32得到上结果
```
c.字面值常量

2.2变量
变量定义
变量声明和定义的关系
标识符
名字的作用域

a.变量定义
初始化和赋值：初始化不是赋值，初始化的含义是创建变量时赋予一个初始值；赋值是吧对象的当前值擦除，而以一个新的值代替。

默认初始化
如果内置变量的值没有初始化，他的值由定义的位置决定，定义于任何函数体之外的变量被初始化为0
定义于函数体内的变量没有初始化的话，他的值时未定义的
类的对象如果没有显式的初始化，则其值由类确定

b.类的定义和声明的关系
声明使得名字为程序所知
而定义负责创建于名字关联的实体，定义还申请内存空间，可能为变量赋初值

如果想要声明一个变量而非定义，则添加关键字extern
包含了显式初始化的声明即成为定义

```
int i;  //定义
extern int a; //声明
```

如果试图初始化一个extern关键字标记的变量，将引发错误
变量能且只能被定义一次，但是可以被多次声明

2.3复合类型
引用
指针
理解复合类型的声明

**引用**

引用是起别名，引用不是对象，一经定义不能再绑定到其他对象，不能定义引用的引用

**指针**

指针是一个对象，允许对指针赋值拷贝，还可以指向其他对象，指针无须在定义时赋初值，如果没有初始化，指针将拥有一个不确定的值，
引用不是对象，没有实际地址，不能定义指向引用的指针

指针空值为NULL的预处理变量，他的值就是0，用NULL和0初始化指针是一样的。
但是直接把int赋给指针是错的，即使int变量的值为0

记住赋值永远改变的是等号左边的对象

```c++
int i=4;
int *pi=0;   //pi指针初始化，但是不指向任何对象
int *pi2=&i;  //pi2指针指向i
pi2=0;    //pi2指针也不指向任何对象
```

```
void*指针
```

可用于存放任意对象的地址
操作受限：
与其他指针比较、作为函数输入输出、赋值给其他void 星指针、不能直接操作void 星指针所指对象，因为不知道对象的类型

复合类型的声明
变量的定义包括一个基本数据类型和一组声明符

类型修饰符（*或 &）作用于本次定义的全部变量
两种写法

```
第一种 把修饰符和变量标识符写在一起 如 int *p1, *p2;
第二种 把修饰符和类型名写在一起    如 int* p1, p2;   //这里p1是指针，p2是个int变量
```

指向指针的指针

指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针中


指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针，但是指针是对象，可以定义指向指针的引用

```
int i=42;
int *p;
int *&r=p; //r是一个对指针的引用
从右向左 &说明r是一个引用，*说明r引用的是一个指针
```

##### 2.4 const限定符

const的引用
指针和const
顶层const
constexpr和常量表达式


前有博客看到，看到const先想到两个字 “只读”

初始化和const
初始化，如果利用一个对象去初始化另一个对象，则它们是不是const都无关紧要

```
int i=42;  
const int ci=i;
int j=ci;
```


默认状态下，const仅在文件内有效

```
const int i=0;
```

编译器在编译过程中把用到该变量的地方都替换成对应的值

const的引用

```
const的引用		普通对象

非const的引用		常对象
```

引用的类型必须与所引用对象的类型一致，
一种例外是在初始化常量引用时允许用任意表达式作为初始值，只要表达式的结果能转换成引用的类型即可

```
double dval=3.14;
const int &ri =dval;
```
上述发生了

```
const int temp =dval; //由双精度浮点数生成一个临时的整型常量
const int &ri = dval;  //让ri绑定这个临时量
```


指针和const

```
指向常量的指针		
const double pi =3.14;
double *ptr = &i;


指针本身是常量
int const*p=&pi
```

顶层const表示指针本身是常量
底层const表示指针所指的对象是常量

2.5 处理类型

类型别名
auto
decltype

两种方法定义别名，一种是传统的typedef

```
typedef double wages;
typedef wages base,*p;    //base是double的同义词，p是double*的同义词
```

另一种是using

```
using SI = Item;  //SI是Item的同义词
```

类型别名指代符合类型

```
typedef char *pstring;  //pstring 是char *的别名
const pstring cstr=0;	//cstr是指向char的常量指针
const pstring *ps;      //ps是一个指针，他的对象是指向char的常量指针
```

上述两条声明语句的基本数据类型都是const pstring，const是对给定类型的修饰。pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。切不可将其简单的替换进行理解，比如：

`const char *cstr = 0;    //这是对const pstring cstr的错误理解`

声明语句中用到pstring时，其基本数据类型是指针。可是用char \*重写了声明语句后，数据类型就变成了char，\*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明的含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。


预处理器概述

预处理变量保护

```
#ifndef 
#define

...

#endif
```



------------

