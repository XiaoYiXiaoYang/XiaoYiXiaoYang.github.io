---
title: 数据结构（哈夫曼、树-二叉树转换）
date: 2019-12-25 11:14:36
tags: [数据结构]
categories: [学习笔记]
---

 哈夫曼编码是前缀编码，保证解码唯一性，还介绍了树、森林、二叉树的转换

<!--more-->



先复习树和森林转换为二叉树
**可能性：**从树的孩子兄弟表示法和二叉树的二叉链表表示法可以看出，树的孩子兄弟表示法实质上是二叉树的二叉链表表示形式，左孩子指针和有兄弟指针分别相当于二叉链表的左孩子和右孩子指针。

**树转换为二叉树：**
1.加线--树中所有相邻兄弟结点之间加一条连线
2.去线--树中的每个结点，只保留它与第一个孩子结点之间的连线，删去他与其他孩子结点之间的连线
3.层次调整--

调整结果:树中的每个结点的左孩子右兄弟变成了它的左右孩子

**森林转换为二叉树**
1.每棵树转换为一棵二叉树
2.从第二个二叉树开始，依次把后一个二叉树的根节点作为前一棵二叉树根节点的右孩子。

**二叉树转换为树**
1.加线----如果结点x是其双亲y的左孩子，则把结点x的右孩子，右孩子的右孩子...都用结点y连起来
2.去线----删去原二叉树中所有双亲结点与右孩子的连线
3.层次调整

调整结果：再把二叉树中的右孩子还原为人家的右兄弟

**哈夫曼树**（也称为最优二叉树）

叶子结点的权值：对叶子结点赋予有意义的数值量
二叉树的带权路径长度：从根节点到各个叶子结点的路径长度与相应叶子结点的权值的乘积之和

哈夫曼算法：
1.初始化，由给定的n个权值构造n棵只有一个根节点的二叉树，从而得到一个二叉树集合
2.选取与合并，在集合中选取根节点的权值最小的两棵二叉树分别作为左右子树构造一棵新的二叉树，这棵新二叉树的根节点的权值为其左右子树根节点的权值之和
3.删除与加入在集合中删除作为左右子树的两棵二叉树，并将新建立的二叉树加入集合

weight：权值
lchild保存左孩子在数组中的下标
rchild保存右孩子在数组中的下标
parent保存双亲结点在数组中的下标

伪代码：

```c++
void HuffmanTree(element huffTree[],int w[],int n){
	for(int i =0;i<2*n-1;i++){
		huffTree[i].parent=-1;
		huffTree[i].lchild=-1;
		huffTree[i].rchild=-1;
	}
	
	for(int i=0;i<n;i++){
		huffTree[i].weight = w[i];
	}
	for(int k =n;k<2*n-1;k++){  //n-1次合并
		Select(huffTree,i1,i2);  //权值最小的两个结点，下标i1,i2
		huffTree[i1].parent=k;
		huffTree[i2].parent=k;
		huffTree[k].weight=huffTree[i1].weight+huffTree[i2].weight;
		huffTree[k].lchild=i1;
		huffTree[k].rchild=i2;
	}
}

```



关于合并for循环的思考：在哈夫曼算法构造哈夫曼树的过程中，非叶子结点的度均为2，所以具有n个叶子节点的哈夫曼树共有2n-1个结点，其中有n-1个非叶子结点，他们是在n-1次合并过程中生成的，
n-1次合并：第一次选两个结点合并，后面将合并的加入再选一个继续合并，n个结点，n-1次合并



**哈夫曼编码**



前缀编码：设计不等长编码时，必须考虑解码的唯一性，如果一组编码中任一编码都不是其他任何一个编码的前缀，则称这组编码为前缀编码
哈夫曼编码：将需要编码的字符集作为叶子结点，将字符集中每个字符在字符串中出现的频率作为权值，进行哈夫曼树的构造，规定哈夫曼树的左分支代表0，右分支代表1，则从根节点到每个叶子结点所经过的路径组成的0、1序列就是该叶子结点所对应字符的编码，称为哈夫曼编码。



------------

*2019-03-29 15:40:05 星期五
萧逸小杨*