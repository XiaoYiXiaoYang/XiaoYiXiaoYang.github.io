---
title: 计算机网络----TCP
date: 2019-12-25 13:30:09
tags: [计算机网络]
categories: [学习笔记]
---

<center>
 较为复杂但是非常重要的TCP协议和可靠传输的工作原理
</center>
<!--more-->



#### 传输层协议概述

涉及的是两个主机进程之间的通信，及ip+port



#### 传输控制协议TCP概述

- TCP是**面向连接的运输层协议**


- 每一条TCP连接只能有两个端点（连接时点对点的）


- TCP提供可靠交付的服务（无差错，不丢失，不重复）


- TCP提供**全双工通信**（TCP连接的两端设置有发送缓存和接收缓存，用来存放双向通信的数据）


- 面向字节流（流入到进程或从进程流出的字节序列）虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流


- TCP连接是一条虚连接（逻辑连接）[真正传输时先给IP层，IP层加上IP头部再传送至数据链路层，再加首部，发送到物理链路去传]


- 
  TCP并不关心应用程序一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP发送的报文长度是应用进程给出的)




### TCP的连接

TCP把连接作为最基本的抽象，每一条TCP连接有两个端点，TCP连接的端点叫**套接字**

端口号拼接到IP地址即构成了套接字

此套接字非彼套接字：**此套接字是IP地址:端口号**

其他套接字：允许应用程序访问连网协议的应用编程接口API



### 可靠传输的工作原理

#### 停止等待协议

##### A是发送方 B是接收方

**“停止等待” 就是没发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组**

A是发送方  B是接收方

A只要超过一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组，叫做**超时重传**

需要在没发送完一个分组就设置一个**超时计时器**，如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器

1.A在发送一个分组后，**必须暂时保留已发送的分组的副本**，只有收到确认后才清除副本

2.**分组和确认分组需要编号**，才能明确

3.**超时计时器的重传时间设置应该比数据再分组传输的平均往返时间更长**


##### 确认丢失和确认迟到

确认丢失

当 B发送的对M1分组的确认丢失了，A会在超时后重传这个分组，此时B的动作

1.丢弃这个重复的分组，不向上层交付

2.向A发送确认，不能认为已经发送过确认就不再发送，因为A之所以重传表示没有收到对M1的确认

确认迟到

传输过程没有差错，但B对分组M1的确认迟到了，此时A会收到重复的对M1分组的确认，A的动作

收下后丢弃


这种机制交**自动重传请求ARQ**

缺点：信道利用率太低

**为了提高效率，使用流水线传输**

**连续ARQ协议**

发送方和接收方维护一个滑动窗口，连续发送连续确认

### TCP报文段格式

单位是位 和 字节，不同的哦

**源端口** 2字节

**目的端口**  2字节

**序号**  4字节 (TCP连接中传送的字节流的每一个字节都按顺序编号)

**确认号**  4字节  (**期望收到对方下一个报文段的第一个数据字节的序号**)

例如：B收到了A发送的数据，A的序号字段值501，数据长度200字节，则B期望收到下一个数据序号为701，于是B在发送给A的确认报文段中把确认号置为701

**数据偏移**： 4位 指出TCP数据起始处距离TCP报文起始处的距离

**保留**： 6位

**紧急URG**： 1位

**确认ACK**：1位  当ACK=1时，确认号字段才有效

**推送PSH**：1位

**复位RST**：1位  当RST=1，表示TCP连接出现严重错误，必须释放连接 

**同步SYN**：1位，用来建立连接时同步序号

**终止FIN**：1位，用来释放一个连接

**窗口**：2字节

**检验和**：2字节

**紧急指针**：2字节

**选项**：可达40字节


**最大报文长度MSS**


### TCP可靠传输

#### 以字节为单位的滑动窗口

TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。

TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。

TCP 两端的四个窗口经常处于动态变化之中。

发送方窗口：凡是发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用

接收方：收到的数据可能是乱序的，那么要先保存，只对按序收到的数据的最高序号确认


1.虽然发送方的窗口由接收方的窗口大小而定，但是同一时刻，他们窗口大小不一样大

2.对于不按序到达的数据没有明确规定，如果丢掉可能浪费网络资源，所以先保留，等到缺少的字节流收到之后，再交付上层的应用进程

3.接收方有累积确认功能，

#### 超时重传时间的选择

重传机制是 TCP 中最重要和最复杂的问题之一。

TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。


那么这个重传时间到底应该设置多少呢？

报文段往返时间RTT

加权平均往返时间RTTs

新的RTTs = (1-a)RTTs旧的 + aRTT新样本

超时重传时间RTO

RTO = RTTs + 4 x RTTd

RTTd是RTT偏差的加权平均值

新的RTTd = (1-b)RTTd旧的 + b x | RTTs - 新的RTT样本 |

例：
发送一个报文段，重传时间到了，则重传，然后收到了确认，但是不知道这个确认是对重传的确认还是对第一个的确认

Karn提出的算法：在计算加权平均RTTs的时候，只要报文重传了，就不采用其往返时间的样本。这样得出的加权平均RTTS 和 RTO就比较准确

问题：有可能报文时延增大，因此在原来的重传时间内不会收到确认，于是重传，但根据Kern算法，不考虑超时重传的报文段的往返时间样本，这样，超时重传时间就无法更新

改进：报文每重传一次，就把超时重传时间RTO增大一些，设置为旧的重传时间的2倍，当不再发生重传的时候又会更新重传时间


#### 选择确认SACK

TCP通信时，如果发送序列中间某个数据包丢失，TCP会通过重传最后确认的分组后续的分组，这样原先已经正确传输的分组也可能重复发送，降低了TCP性能

SACK（Selective Acknowledgment，选择确认）技术，使TCP只重新发送丢失的包，不用发送后续所有的分组，而且提供相应机制使接收方能告诉发送方哪些数据丢失，哪些数据已经提前收到等。

在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。



### TCP流量控制

流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 

#### 利用滑动窗口实现流量控制

rwnd =400

指出接收窗口大小

如果接收方向发送方指出接收窗口大小为0，之后又有空间了，向发送方发送，但是报文丢失了，则发送方等接收方有空间，接收方等发送方发数据，陷入死锁。。

TCP 为每一个连接设有一个**持续计时器。**

只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。

若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。


#### TCP的传输效率

关于TCP的传输效率问题，需要从三方面来考虑，1.何时发送；2.少字节发送数据问题；3.糊涂窗口综合症问题

3.1 TCP报文的发送时机：

第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。

第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作。

第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。

3.2 少量字节发送数据问题：

问题描述：如果应用程序一次产生一字节数据，这样会导致网络由于太多的包而过载。如：从键盘输入的一个字符，占用一个字节，可能在传输上造成41字节的包，其中包括1字节的有用信息和40字节的标题数据。

解决方案（NAGLE算法）：发送端的应用进程将欲发送的数据**逐个字节地送到TCP缓存，**则发送端就**将第一个字符先发送出去。将后面到达的字符都缓存起来**。当接收端收到对第一个字符确认后，再将缓存中的所有字符装成一个报文段发送出去，同时继续对随后到在的字符进行缓存。只有在收到对前一个报文段确认后才继续发送下一个报文段。

　3.3 **糊涂窗口综合症**问题：

问题描述：设想一种情况：接收端缓存已满，而交互式的应用进程一次只从缓存中读取一个字符，然后向发送端发送确认，并将窗口设置1个字节。接着发送端又发来1个字符。接收端发回确认，仍然将窗口设置为1个字节。这样下去，网络效率非常低。

解决方案：接收端等待一段时间，使得缓存已有足够空间容纳；或者缓存已有一半空的空间，再向发送端发送确认。

### TCP拥塞控制

前言：拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载


当提供的负载达到某一数值的时候，网络的吞吐量就下降到零，网络已经无法工作，这就是所谓的**死锁**

进入负载的分组因为排队时间过长，发送端进行了重传，造成拥塞


#### 慢开始

慢开始不是指cwnd的增长速度慢（指数增长），而是指TCP**开始发送设置cwnd=1**。 

思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

增长速度：每经过一个往返就把拥塞窗口增长2倍


为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限（ssthresh状态变量） 

当cnwd＜ssthresh，使用慢开始算法 
当cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法 
当cnwd＞ssthresh，使用拥塞避免算法

#### 拥塞避免

拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 

思路：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞控制窗口加一。

增长速度：每经过一个往返就把拥塞窗口增长2倍

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法


#### 快重传

快重传要求接收方**在收到一个失序的报文段后就立即发出重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。

快重传算法规定，**发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期**。

由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量


#### 快恢复

1.采用快恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。 

2.当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。 

3.考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。






### 三次握手

客户端服务器建立连接

客户端主动打开，发送报文SYN=1,seq=x，进入SYN-SENT状态   
【同步位SYN置1表示发送请求，seq=x初始序号x】

服务器收到请求报文，回复确认报文段ACK=1 ack=x+1，
并且带着同步报文段SYN=1,seq=y，进入SYN-RCVD状态  
【确认报文段置ACK位为1，ack确认序号x+1；同步报文段同步位SYN为1,序号seq为y】

客户端收到确认，再回复确认	ACK=1，seq=x+1，ack=y+1，进入ESTABLISHED（已建立连接状态）   
【ACK位置1，确认号ack为y+1，自己的序号seq为x+1】

**序号的理解**：之前对序号理解不够深入，
首先客户端发送序号x，服务器确认自己的序号为y
客户端在确认服务器的确认时，序号是x+1

则下一次客户端向服务器传输数据序号就从x+2开始

而服务器向客户端传输数据序号就从y+1开始

序号是一个方向传输使用的


**确认号的理解**

首先服务器确认客户端的第一次连接请求确认号ack为x+1

则下次客户端发送的包序号就是从x+1开始

客户端对服务器确认包中ack为y+1，则猜测服务器向客户端下次发送数据序号就是从y+1开始


**为什么三次？能不能两次？**

**防止已经失效的请求又传送到服务器**

**则服务器会进入等待，此时客户端并没发送数据，服务器苦苦等待**

正常情况，A发出连接请求，但是连接请求报文丢失导致未收到确认，A重传一次连接请求，后来收到了确认建立连接，数据传输完毕后，就释放连接。


一种异常情况，A发出连接请求，但是连接没丢失，长时间滞留在网络结点了，然后这个连接请求在延误到了AB连接释放以后的某个时间，这是一个已失效的报文段，但是B在接收到这个请求就以为A又发出一次新的请求，所以想A发送确认报文段，同意建立连接

如果不采用3次握手，此时已经建立连接，但是A并不会发送数据，B只能苦苦等待


### 四次挥手

客户A FIN=1,seq=u，进入FIN-WAIT-1状态

服务器B ACK=1 ack=u+1，seq=v，进入CLOSE-WAIT状态，，A收到B的确认后进入FIN-WAIT-2状态，A到B断开，半连接状态

**A到B的连接断开，此时B可能还在向A发送数据**

服务器B ACK=1 ack=u+1 seq=w，FIN=1，进入LAST-ACK状态

客户A  ACK=1,seq=u+1，ack=w+1，B收到则关闭连接，A进入TIME-WAIT状态


**TIME-WAIT状态等待设置时间为2MSL
MSL为最长报文寿命**

1.保证A发送的最后一个ACK报文段能到达B

2.防止已失效的连接出现在本连接








2019-11-03 19:21:12 星期日