---
title: 编译原理（第二章 词法分析）
date: 2020-01-08 20:59:39
tags: [编译原理]
categories: [学习笔记]
---

 任务是把构成源程序的字符流翻译成词法记号流

<!--more-->

#### 第二章 词法分析

捋一下重点

**从正规式构造NFA**

归类 
识别&euro;的NFA 
识别a的NFA
识别s | t的NFA
识别正规式st的NFA
识别正规式S * 的NFA

图2.20 识别(a|b)*ab 的NFA


**从NFA确定化DFA**：子集构造法

算法好难描述

初始状态的&euro;闭包得到一个状态，然后对输入符号求&euro（move(A,a)）

//注意：求move不包含A原有的；求&euro一定包含A原有的

得到DFA

图2.12 NFA构造DFA


**DFA化简**

对DFA M，如果从状态s出发，在面临输入串w时，最终停在一个接收状态，而从状态t出发，面临输入w时，它停在一个非接受状态，或者反过来，串w可以却别状态s和状态t

图2.9 最简化的DFA

**极小化DFA状态数算法**

1.两个子集，非接受状态子集和接受状态子集
2.对非接受状态子集进行细分
3.如果细分不了执行4，如果还能继续2
4.选一个状态代表这个不可区分的状态子集
5.如果有死状态，则去除，从开始状态不可达的状态也要删除


#### 刷题

**叙述由正规式描述的语言**

0(0 | 1)*0   0开始，0结尾的长度大于1的所有串的集合

（（&euro; | 0）1*）*    {0,1}上所有串的集合

(00 | 11)* ((01 | 10) (00 | 11)* (01 | 10)(00 | 11)* )*  所有0和1的个数都是偶数的集合

某语言的注释，他以/*开始 */结束，但是任何前缀不以*/结尾   
other -> a | b |...
otherI-> a | b |...
comment ->/* other* (乘号乘号 *otherI other*)* 乘号* */

所有不含子串011的0和1的串    (1 | 01)* 0*


**构造NFA->DFA->最简DFA**

例题  (a | b)*ab
(a | b)*(aa | bb)(a |b)*
(a | b)*a (a | b)
习题2.7,2.8,2.12


**构造DFA**

书上例题  (a | b)*ab

能被三整除的二进制数

能被5整除的二进制数

{0,1}上0和1的个数都是偶数的字符串

0开始1结尾的串

接受所有大于101的二进制数





------------