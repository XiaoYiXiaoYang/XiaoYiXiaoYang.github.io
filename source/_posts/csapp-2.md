---
title: CSAPP-(链接)
date: 2019-12-21 20:48:02
tags: [深入理解计算机系统]
categories: [学习笔记]
---

链接器的行为和功能

<!--more-->



链接可以用于编译时、加载时、运行时



链接：静态链接、动态链接



装入：静态装入、静态重定位、动态重定位



#### 编译器驱动程序

编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器





#### 静态链接



以一组可重定位目标文件和命令行作为参数输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节组成



- 符号解析

  目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。符号解析的目的是将每个符号引用和一个符号定义关联起来

- 重定位

  编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与内存位置关联起来，从而重定位这些节，然后修改所有对于这些符号的引用，使得他们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令



```
比如call function
变成 JMP  fun
```



#### 目标文件

- 可重定位目标文件
- 可执行目标文件
- 共享目标文件



编译器和汇编器生成可重定位目标文件，链接器生成可执行目标文件



#### 可重定位目标文件



典型的ELF可重定位目标文件的格式

|   ELF头   | 描述了生成该文件的系统的字的大小和字节顺序         |
| :-------: | -------------------------------------------------- |
|   .text   | 已编译程序的机器代码                               |
|  .rodata  | 只读数据                                           |
|   .data   | 已初始化的全局变量和静态变量                       |
|   .bss    | 未初始化的全局变量和静态变量                       |
|  .symtab  | 符号表，存放程序中定义和引用的函数和全局变量的信息 |
| .rel.text | 一个.text节中位置的列表                            |
|  .debug   | 一个调试符号表                                     |
|   .line   | 原始源程序中的行号和.text节中机器指令之间的映射    |
|  .strtab  | 一个字符串表                                       |
| 节头部表  |                                                    |



.bss 叫“块存储开始”  “Blocking Storage Start”



#### 符号和符号表

每个可重定位目标模块都有一个符号表



- 由模块m定义并能被其他模块引用的全局符号
- 由其他模块定义并被模块m引用的全局符号
- 只被模块m定义和引用的全局符号



#### 符号解析



方法：将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。



全局符号：如果编译器遇到一个不是在当前模块定义的符号时，会假设该符号是在其他某个模块定义的，生成一个链接器符号条目，并把它交给链接器处理



##### 链接器如何解析多重定义的全局符号

函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号



- 不允许有多个同名的强符号
- 如果有一个强符号和多个弱符号同名，那么选择强符号
- 如果有多个弱符号同名，那么从这些弱符号中任意选择一个



##### 与静态库链接



将所有相关的目标模块打包成为一个单独的文件，称为静态库，它可以用作链接器的输入，当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块



**链接时，链接器将只复制被程序引用的目标模块**



##### 链接器如何使用静态库来解析引用

在Linux系统中，静态库以一种称为存档的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合



在符号解析阶段，链接器从右到左按照他们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件



*可重定位目标文件集合E、未解析的符号集合U、在前面输入文件已经定义的符号集合D*

- 对命令行上输入的文件f，链接器判断f是一个目标文件还是存档文件，如果是目标文件，添加到E；
- 如果f是一个存档文件，那么链接器尝试匹配U中未解析的符号和由存档文件成员定义的符号
- 如果链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止



#### 重定位

合并输入模块，并为每个符号分配运行时地址



- 重定位节和符号定义。将所有相同类型的节合并为同一类型的新的聚合节
- 重定位节中的符号引用。链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址



##### 重定位条目

汇编器生成一个目标模块时候，它不知道数据和代码的最终位置，所以，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用



##### 重定位符号引用

1.重定位PC相对引用

2.重定位绝对引用





#### 可执行目标文件

ELF可执行目标文件被设计的很容易加载到内存，可执行文件的连续的片被映射到连续的内存端倪。



#### 加载可执行目标文件

加载器将可执行目标文件的数据和代码从磁盘赋值到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个过程叫加载



每个Linux程序有一个运行时内存映像

|  内核内存  |                                    |
| :--------: | :--------------------------------: |
|     栈     |                                    |
| 内存映射区 |                                    |
|     堆     |                                    |
|  读/写段   |    .data，.bss(全局/静态存储区)    |
| 只读代码段 | .init， .text，.rodata(文本常量区) |



代码段总是从地址0x400000处开始，后面是数据段。

运行时堆在数据段之后，通过调用malloc库往上增长

堆后面的区你敢信的域是为共享模块保留的

用户占总是从最大的合法用户地址(2^48 - 1)开始，向较小内存地址增长

从地址2^48开始，是为内核中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分



#### 动态链接共享库



静态库缺点：

1.需要定期维护和更新，必须显式的重新让程序和更新了的库重新连接

2.调用的每个静态库的函数，每次都要复制到内存中去



共享库致力于解决静态库缺陷的产物，在运行和加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程叫**动态链接**，是由一个叫**动态链接器**的程序执行



共享库也称为共享目标，在Linux目标系统中常用.so后缀来表示，微软的操作系统使用了大量共享库，称为DLL



所有引用共享库的可执行目标文件共享这个so文件中的代码和数据，而不是像静态库的内容那样被赋值和嵌入到引用它们的可执行文件中



- 当创建可执行目标文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程

- 当加载器加载和执行可执行文件时，它注意到目标文件包含一个.interp节，这一节包含动态链接器的路径名，加载器不会像它通常那样将控制传递给应用，而是加载和运行这个动态链接器，动态链接器执行重定位完成链接

1.重定位lib.so的文本和数据到某个内存段

2.重定位可执行目标文件对由共享库定义的符号的引用

此时开始，共享库的位置就固定了并且在程序执行的过程中都不会改变



#### 从应用程序中加载和链接共享库





#### 位置无关代码



#### 库打桩机制



























