---
title: Java基础（类和对象）
date: 2020-01-08 16:23:39
tags: [JavaWeb]
categories: [学习笔记]
---

 纯面向对象的语言，面向对象部分才是精华

<!--more-->

**类和对象**

属性是事物静态特征的抽象
操作使事物动态特征的抽象

抽象（从被研究对象中舍弃个别的、非本质的、或与研究主旨无关的次要特征，而抽取与研究工作有关的实质性内容加以考察）

过程抽象：任何一个完成特定功能的操作序列，其使用者都可以把它看做一个单一实体。尽管这个操作可能是由一系列更低级的操作完成的

数据抽象：把系统中需要处理的数据和施加于这些数据之上的操作结合为一个不可分的系统单位，根据功能、性质、作用等因素把它们抽象成不同的抽象数据类型。
每个抽象数据类型既包含了数据，也包含了针对这些数据的授权操作，并限定数据的值只能由这些操作来观察和修改。
一个抽象数据类型表示一组数据和一组公共操作，
1.用户不需要了解详细的实现细节就可以使用它。
2.对用户屏蔽了数据类型的实现
3.由于接口规定了用户与数据之间所有可能的交互，也就避免了用户对数据的非授权操作

对象：把事物的静态特征抽象成了一组数据，把事物的动态特征抽象成了一组方法
类：具有相同属性和方法的一组对象的集合

使用系统类的方式
1.直接使用系统类  2.继承系统类  3.创建系统类的对象

**创建对象**
1.声明引用变量 2.创建对象 3.初始化对象

```
class A{
...
}
A a,b;
```

声明两个引用变量，他们都属于A类，声明引用变量时，系统只为该变量分配引用空间，存放在Java定义的栈内存，其值为**null**

创建时使用new操作符

```
a = new A();

```

**new为对象分配内存空间，且存放在Java定义的堆内存中，引用变量的值时该对象存储的地点**

初始化对象可以使用a.默认初始化原则赋值，b.用赋值语句赋值 ，c.用Java的构造函数赋值

| 数据成员类型           | 默认取值 |
| ---------------------- | -------- |
| byte、short、int、long | 0        |
| float                  | 0.0f     |
| double                 | 0.0d     |
| boolean                | false    |
| char                   | '\u0000' |
| 所有引用类型           | null     |

**构造方法**

与类名相同
不能对构造函数指定类型，有隐含的返回值，由系统内部调用
构造函数可以重载可以继承
如果没有构造函数，系统自动生成无参构造函数

**类修饰符**

1.无修饰符
如果一个类前无修饰符，则这个类只能被同一个包中的类使用，也就是可以被统一程序文件中的类使用，但不能被其他程序文件中的类使用

2.public修饰符
公共类，可以被同一个包中的类使用，还可以被其他包中的类使用，在程序中可以import引用其他包中的public类，Java规定在一个程序中只能定义一个public类，

3.final修饰符
最终类，不能被其他任何类所继承，a.完成某种标准功能，b.提高程序可读性，不能一直派生，c.提高安全性，病毒的闯入是利用一些处理关键信息的类派生子类，则截断了病毒闯入的途径。

4.abstract修饰符
抽象类，其作用在于将许多有关的类组织在一起，提供一个公共的基类，为派生具体类奠定基础，当一个类中出现了一个或多个用abstract修饰的方法时，必须在这个类的前面加上abstract修饰符，将其定义为抽象类。

可以是public abstract  也可以public final。但是不能abstract final

**数据成员**

1.static修饰的静态数据成员
被保存在内存区的公共存储单元，可以通过类名.成员名访问，static类数据成员仍属于类的作用域，还可以使用public static，private static

静态数据成员初始化
静态初始化器
静态初始化器对类的静态数据成员进行初始化，而构造方法用来对新创建的对象进行初始化
静态初始化器不是方法，没有方法名，参数值和参数表
静态初始化器是在他所属的类加载到内存时由系统调用执行的，而构造方法是new操作符产生新对象时自动执行的

```
class C{
static int n;
{n=20;}
}

```

2.final 修饰的最终数据成员
最终数据成员可以在声明时进行初始化，也可以通过构造方法赋值，但不能在程序的其他部分赋值，它的值在程序整个执行过程中是不可改变的。
final修饰符说明常量时，
a.需要说明常量的数据类型并指出常量的值
b.若一个类有多个对象，而某个数据成员是常量，最好将此常量声明为static，即用static final修饰，这样做更节省空间

**成员方法**

修饰符：访问权限修饰符public、protected、private；非访问权限修饰符 static、final、native、abstract；访问权限修饰符指出满足什么条件时该策划稿能源方法可以被访问，非访问权限修饰符指明成员方法的使用格式

方法体中的局部变量
只在本方法体中有效可见；在方法体内定义变量时，变量前不能加修饰符；局部变量在使用前必须明确赋值，否则编译时会出错

形参、实参
实参对形参的数据传递是值传递，即只能由实参传递给形参，而不能由形参传递给实参。程序中执行到引用成员方法时，Java把实参值拷贝到一个临时的存储区（栈）中，形参的任何修改都在栈中进行，当退出该成员方法时，自动清除栈中的内容

方法的引用方式
方法语句、方法表达式、方法作为参数、通过对象来引用

1.static修饰的静态方法
static方法属于整个类，它在内存中的代码随着类的定义被分配和装载
引用静态方法时，可以使用对象名访问，也可以使用类名访问
static方法只能访问static数据成员；但非static方法可以访问static数据成员
static方法只能访问static方法；但非static方法可以访问static方法
static方法不能被覆盖
main方法是静态方法

2.final修饰的最终方法
如果类的某个方法被final修饰符限定，则该类的子类不能覆盖父类的方法（安全）

3.native修饰的本地方法
将其他语言嵌入Java语言中


**消息、继承、多态**

对象之间的联系是通过消息传递来实现的
性质：1.同一对象可接受不同形式的多个消息
2.相同形式的消息可以发送给不同的对象
3.消息的发送可以不考虑具体的接收者，对象可以响应消息，也可以不予理会

公有消息：由外接对象直接发送给这个对象的消息
私有消息：对象发送给自己的消息

特定于对象的消息分为以下三种：
1.可以返回对象内部状态的消息
2.可以改变对象内部状态的消息
3.可以做一些特定操作，改变系统状态的消息

**访问控制**

1.公共访问控制符public
对同一个包中的类可见，对其他包中的类使用import导入即可见
但是并不代表该类的数据成员和成员方法也对其他类可见，由这些数据成员和成员方法决定，只有类修饰符为public，且数据成员和成员方法修饰符也是public时才可见

2.无访问控制符（友好访问）
只有同一个包中的对象才能访问和引用这些类型，又叫“包访问型”

3.私有访问控制private
private修饰的数据成员和成员方法只能被该类自身访问和修改而不能在任何其他类访问和引用

4.保护访问控制符protected
可以被三种类引用：该类自身、与他同在一个包中的其他类、在其他包中该类的子类


**多态**

（多态是一个程序中具有相同名字而内容不同的方法共存的情况）

重载
主要通过形参列表参数个数、参数的数据类型和参数的顺序等方面区分

覆盖
子类对父类方法进行重写，在引用时指明引用的是父类的方法还是子类的方法，就可以把它们区分。

**继承**

单继承：extends关键字指明继承的类

子类可以继承父类的所有非私有数据成员
子类可以继承父类的所有非私有成员方法

数据成员隐藏：在子类中重新定义一个与父类中已定义的数据成员名完全相同的数据成员，默认是引用自己的，将父类继承来的隐藏
成员方法隐藏：在子类中重新定义一个与父类同名的成员方法，实现对父类方法的覆盖。
数据成员隐藏只是使父类的不见，其数据成员在子类对象中仍然占有自己独立的内存空间，而成员方法覆盖将清除父类方法在子类中占的内存。

this 代表当前对象的引用---》当前对象的数据成员、成员方法，有重载的构造方法时，用来引用同类的其他构造方法
super 代表当前对象的直接父类对象 ----》父类的数据成员、成员方法、调用直接父类的构造函数

**构造方法的重载与继承**

一个类的若干构造方法可以相互调用，一个构造方法调用另一个构造方法时，使用this，且这个调用语句应该是整个构造方法的第一条可执行语句

```
class A{
	A(int x){this.x=x;}
	A(int x,int y){this(x);this.y=y;}
}
```

构造方法的继承
子类无条件继承父类的不含参数的构造方法
如果子类没有构造方法，则继承父类的无参构造函数，并把这些构造函数作为自己的构造方法，如果子类定义了构造方法，则在创建新对象时，它先执行父类的无参构造方法，再执行自己的构造方法
*对于父类的有参构造方法，子类通过super调用，但这个调用语句必须是第一条可执行语句*

向方法传递对象
传递给方法的参数若是对象，则实参和形参的对象引用指向同一个对象，因此方法中对对象的数据成员的修改会使实参对象的数据成员值发生同样的变化，这种参数传递方式叫“双向地址传递”

**抽象类、接口与包**

抽象类刻画共有行为的特征，并通过继承机制传送给它的派生类，派生类实现
抽象类中可以有0个或多个抽象方法，也可以含有非抽象的方法
抽象类中可以没有抽象方法，但是，有抽象方法的类必须是抽象类
对于抽象方法来说，在抽象类中只指定其方法名及类型，而不书写实现代码
抽象类可以派生子类，子类中必须实现抽象类中的所有抽象方法
抽象类不能创建对象，由子类创建
父类中已有同名的abstract方法，子类中不能再有同名的抽象方法
abstract不能与final并列修饰同一个类
abstract不能与private、static、final、native并列修饰同一个方法

**接口Interface**

修饰符public 和 默认
public是公共接口可以被所有的类和接口使用
默认只能被同一个包中的其他类和接口使用

接口也具有继承性，定义一个接口时可以通过extends关键字声明该接口时某个已经存在的父接口的派生接口，他将继承父接口的所有属性和方法，支持多继承

接口中的数据成员都是final static的，即常量，也可以用public final static声明
接口中没有自身的构造方法，其所有成员方法都是抽象方法，默认是public abstract修饰的

实现接口用implements
如果实现某接口的类**不是abstract抽象类**，则在类的定义部分必须实现指定接口的所有抽象方法

如果实现某接口的类**是abstract抽象类**，他可以不实现接口中的全部方法，但是对于这个抽象类的任何一个非抽象的子类而言，他们的父类所实现的接口中的所有抽象方法都必须有实在的方法体，

接口的抽象方法默认是public abstract，所以类在实现方法时，都要**显式使用public修饰符**，否则将被系统警告为缩小了接口与中定义的方法的访问控制范围。


**包**
作用：
1.类名空间，同一个包中的类不能同名，不同包中的类可以同名
2.控制类之间的访问，public类不仅可以供同一个包中的类访问，也可以供其他包中的类访问

**包的创建**
a.public语句，一个源文件只能由一个public类
b.若干属于本包的类声明
	package 包名
就可以创建一个具有指定名字的包，当前.java文件中的所有类被放在这个包中
package shape
package shape.circle
在当前文件夹下创建了一个shape文件夹，又在shape下创建了circle子文件夹

若源文件未使用package，则源文件中的接口和类存在Java的**无名包**中，他们之间可以相互引用非private的数据成员或成员方法，无名包中的类不能被其他包中的类引用和复用

**包的引用**

a.在引入的类前加包名   (shape.Circle c = new shape.Circle())
b.用import关键字加载需要使用的类(import shape.Circle)
c.用import关键字加载整个包(import shape.*)



------------

*2019-04-11 22:25:06 星期四
萧逸小杨*