---
title: 数据结构（查找）
date: 2019-12-25 11:19:24
tags: [数据结构]
categories: [学习笔记]
---

 顺序查找、折半查找、二叉排序树、平衡二叉树‘、Hash表

<!--more-->



**时间复杂度**

基本语句：执行次数与整个算法的执行次数成正比的语句，基本语句对算法运行时间的贡献最大，是算法中最重要的操作。

为了客观反映一个算法的执行时间，可以用算法中基本语句的执行次数来度量算法的工作量，这种衡量效率的方法得出的不是时间量，而是一种增长趋势的度量。
当问题的规模足够大，算法中基本语句的执行次数在渐近意义下的阶，称作算法的渐近时间复杂度。

**ASL**

Average Search Lenth:平均查找长度    
ASL = € Pi * Ci 
pi 为查找第i个记录的概率；ci为查找第i个记录所需的关键码比较次数

**顺序查找**

从线性表的一端向另一端逐个将关键码与给定值进行比较.
特殊的手段是哨兵技术，将待查集合设置在数组的1-n，将要查的元素k放在数组第0个下标处，当查找成功则返回下标值，查找失败则返回下标0

```c++
int Seqsearch(int r[],int n,int k){
    r[0]=k;   //数组配合一点，数组从下标1开始存放待查集合
    int i= n;
    while(r[i] !=k)
        i--;
    return i;
}
```

**折半查找**

要求有序表，在有序表中取中间记录作为比较对象，若与中间记录的关键码相等，则查找成功；若给定值小于中间值，则在左半区查找，若给定值大于中间值，则在右半区查找。

两个思考：
1.如果（low+high）/2 是单数
2.为什么循环结束条件是low<=high

```c++
int BindSearch(int r[],int n,int k){//还是从下标1开始存储
   int low =1;
   int high =n;
   int mid=0;
   while(low<high){
    mid = (low+high)/2;
    if(k<r[mid])    high = mid-1;
    else if(k>r[mid]) low = mid+1;
    else return mid;
   }
}
```

回答问题：
1.如果是单数，取整就完了，中间会有很多次取整的机会
2.low<=high就是结束循环条件，例子走一走

有序表 
0 1  2  3  4  5  6  7
0 7 14 18 21 23 29 31   查14 low = 1  high = 7
	
```
	mid = 4   (low =1 high =3 )
	mid = 2   查找成功
```

查22

```
	mid = 4   (low = 5  high =7)
	mid = 6   (low = 5  high = 5)
	mid = 5   (low = 5   high = 4)
	low>high  返回0
```

- 折半查找判定树

用二叉树来描述折半查找,**判定树的根节点是mid = (1+n)/2 的记录**，根节点左子树是r[1]~r[mid-1] 的判定树 ,根节点的右子树是r[mid+1]~r[n]的记录

和给定值的比较次数等于该记录结点在树中的层数，折半查找判定树的深度为[log2 n] + 1,折半查找的平均时间复杂度也是O(log2 n)

ASL = 1/n * (1*2^0 + 2*2^1 +... + k*2^k-1)
	= log2 (n+1) -1

折半查找判定树也是二叉排序树

- 二叉排序树

性质：
左子树不空，则左子树上所有结点小于根节点的值
右子树不空，则右子树上所有结点大于根节点的值
左右子树也是二叉排序树

**中序遍历**序列即为一个**有序**序列

插入：（递归）
若root是空树，则作为根节点插入
非空：若小于根节点，则插入左子树
	  若大于根节点，则插入右子树

删除：（删除后仍保持二叉排序树的特性）

删除值最小的结点：
左子树的最左下结点s，把s的父结点中原来指向s的指针改为指向s的右孩子（s肯定没有左孩子，否则就不是值最小的结点）

删除结点p为叶子结点
删除叶子结点不影响二叉排序树的特性，将被删除结点的双亲结点的相应指针域改为空指针

删除结点p只有左子树或只有右子树
只需要将删除结点左子树或者右子树替换为其双亲结点的左子树，仍保持二叉排序树的特性；
若p只有左子树，将p删除，把p的左子树接上
若p只有右子树，将p删除，把p的右子树接上

删除结点p既有左子树也有右子树
坏方法：让父节点的左指针指向p的任意一个子树，然后将另一个子树中结点重新插入，这将使二叉排序树的结构发生变化并增加高度

**好方法**：从某个子树中找出一个结点s，其值能代替p的值，这样就可以用结点s的值去替换结点p的值，再删除结点s

**选出s结点**：这个值应该是大于结点p的最小值（中序遍历 结点p的下一个）
或者小于结点p的最大值（中序遍历 结点p的前一个）

**查找:**若k = root->data，则查找成功
若k < root->data 则在root的左子树上查找
若k > root->data 则在root的右子树上查找
直到查找到待查找的子树为空，则查找失败

**查找性能：**具有n个结点的折半查找判定树唯一，根节点为r[mid]，但是含有n个结点的二叉排序树不唯一，其形状取决于各记录被插入二叉排序树的先后顺序,如果二叉排序树是平衡的，则查找效率O(log2 n)
如果二叉排序树完全不平衡（斜树），则查找效率为O(n)

- 二叉平衡树

由二叉排序树引出了二叉平衡树，一棵平衡的的二叉树可以保证查找效率较好的维持和折半查找相近为O(log2 n)

**二叉平衡树性质**：
1.首先他一定是二叉排序树（递归定义 左子树的小  右子树的大）
2.根节点的左右子树深度最多相差1
3.左右子树也是二叉平衡树

平衡因子：该节点的左子树深度与右子树深度之差
最小不平衡子树：在平衡二叉树的构造过程中，以距离插入节点最近的，且平衡因子绝对值大于1的结点为根的树

构造思想：每插入一个结点都检查是否破坏了平衡性，若破坏，则调整

调整的例子
LL型：插入地方为根节点左孩子的左子树，调整为旋转优先
RR型：插入地方为根节点右孩子的右子树
RL型：插入地方为根节点的右孩子的左子树，调整两步 
LR型：插入地方为根节点的左孩子的右子树

练手排序树和平衡树{20，35,40,15,30,25,38}   {12,24,36,90,52,30}
{24,15,38,27，76，130，121}

**Hash查找**

理想情况：不经过比较，直接找到带查值的存储位置下标

key 和 H(key)   key为关键码；H为散列函数（Hash函数、杂凑函数、哈希函数）；H(key)值为所得的存储位置

存储记录：通过散列函数计算记录的散列地址，并按此散列地址存储该记录
查找记录：通过散列函数计算散列地址，并用该散列地址访问该记录

**不适用**：不适用于多个记录有相同的关键码，不适用于范围查找
散列函数的设计：简单、均匀、存储利用率高的散列函数
冲突的处理：两个不同的记录需要存放在同一存储位置，采取方法解决冲突

1.直接定址法        H(key) = a*key +b
	适合关键码集合不大且连续性较好时

2.除留余数法        H(key) = key mod p
	p选的不好增加冲突

3.数字分析法       取关键码位数中的某几位作为散列地址
	适合知道关键码分布的情况

4.平方取中法       对关键码平方，取中间几位作为散列地址
	一个数平方后，中间几位分布较均匀

5.折叠法           从左到右分割成位数相等的部分，几部分叠加求和，求和的最后几位作为散列地址
移位叠加：将各部分最后一位对齐相加
间接叠加：各部分折叠相加

冲突处理

**闭散列表**：无需附加指针域，因此存储效率较高。但由此带来的问题是容易产生堆积，而且某些基本运算不易实现。
**开散列表**：利用链接方法存储同义词，不产生堆积现象，且使得动态查找的基本运算特别是查找、播入和删除易于现实。但由于附加指针域而增加了存储开销。

1.开放定址法   *得到的叫闭散列表*
a.线性探测法    Hi = （H(key)+di） % m （di=1,2,..）
   从冲突位置的下一个位置起依次寻找空的散列地址
   处理冲突过程中出现的非同义词之间对同一个散列地址争夺的现象称为**堆积**
b.二次探测法     Hi = （H(key)+di） % m （di=1^2 ,2^2 ,..）
   位置冲突则向前移动i^2 个单位

c.随机探测法     Hi = （H(key)+di） % m （di=随机数列）
    位置冲突则向前移动i个位置
	
2.拉链法（链地址法）  *得到的叫开散列表*
将所有冲突的记录存储在一个单链表中



*2019-04-18 16:43:47 星期四
萧逸小杨*

