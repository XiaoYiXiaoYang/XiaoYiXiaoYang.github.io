---
title: datastructure-3
date: 2019-12-25 10:52:42
tags: [数据结构]
categories: [学习笔记]
---

 前面讨论的数据结构都属于线性结构，线性结构主要描述具有单一的前驱和后继关系的数据，树结构是一种比线性结构更复杂的数据结构，比较适合描述具有层次关系的数据。应用于编译原理--语法树，数据挖掘--决策树

<!--more-->



**树**

数据元素称为结点
树是n各节点的优先集合，当n==0时，称为空树，任意一颗非空树满足以下：
1.有且仅有一个特定的称为根的结点
2.当n>1时，除根节点以外其余结点被分成m个互不相交的有限集合，其中每个集合又是一颗树，并称为这个根结点的子树。

所以树的定义：有且仅有一个根，根节点没有前驱；除根结点以外，每个结点有且仅有一个前驱，可以有多个后继，由若干子树和根节点组成的

结点的度：某个结点拥有的子树的个数
树的度：树中各节点度的最大值称为该树的度
叶子结点：度为0的结点，也称为终端节点
分支结点：度不为0的结点称为分支节点，也称为非终端节点
孩子结点：某节点的子树的根节点称为该结点的孩子结点
双亲结点：该结点为其孩子结点的双亲结点
兄弟结点：具有同一个双亲的孩子结点互称为兄弟结点
路径：如果n1、n2、n3...nk,满足结点ni为ni+1的双亲，则n1、n2、n3...nk称为从n1到nk的一条路径，
路径长度：路径上经过的边数称为路径长度
祖先、子孙：如果从结点x到结点y有一条路径，那么x就是y的祖先，y是x的子孙
结点的层数、树的深度（高度）：根节点的层数为1，树中所有结点的最大层数称为树的深度，也称为树的高度。
层序编号：将树中按照从上层到下层，同层从左到右的次序依次给他们编以从1开始的连续自然数，这种编号称为层序编号。
有序树：如果树中结点的各子树从左到右都是有次序的，即若交换了结点各子树的相对位置，则构成了不同的树，称这棵树为有序树，反之称为无序树
森林：m棵互不相交的树的集合构成森林。



**树的存储结构**

1.双亲表示法
    用一维数组来存储树的各个结点，数组中的一个元素对应树中的一个结点，数组元素包括树中结点的数据信息以及该结点的双亲在数组中的下标
data  存储结点数据信息
parent  存储结点双亲在数组中的下标

2.孩子表示法
	a、多重链表表示法
		链表中的每个节点包括一个数据域和多个指针域，每个指针域指向该结点的一个孩子结点。
		（1）.指针域的个数等于该结点的度
		data、degree(该节点的度)、child1....childd
		（2）.指针域的个数等于树的度
	b、孩子链表表示法
		用多个单链表表示树的方法，把每个结点的孩子排列起来，看成是一个线性表，且以单链表存储，则n个结点共有n个孩子链表，n个单链表有n个头指针，n个头指针又构成一个线性表
		孩子结点：data、next    
		表头结点：data、firstchild

3.双亲孩子表示法
	将各节点的孩子结点分别组成单链表，同时用一维数组顺序存储树中的各节点，数组元素除了包括结点的数据信息和该结点的矮子链表的头指针之外，还增设一个域存储该结点的双亲结点在数组中的下标。
	data、parent、firstchild
	
4.孩子兄弟表示法
	链表中每个节点除数据域外，还设置了两个指针分别指向该结点的第一个孩子和右兄弟。
	firstchild、data、rightsib
	
**二叉树**
	由一个根节点和两个互不相交的、分别称为根节点的左子树和右子树的二叉树组成，
	特点：1.每个结点最多有两个子树，所以二叉树中不存在度大于2的结点，2.二叉树的有序的，其次序不能任意颠倒，及时树中的某个结点只有一颗子树，也要区分他是左子树还是右子树
	二叉树具有5种基本形态，1.空二叉树 2.只有一个根节点、3.根节点只有左子树，4.根节点只有右子树 5.根节点既有左子树还有右子树

1. 斜树  （所有结点只有左子树的叫左子树）（所有结点只有右子树的叫右子树）

2.满二叉树（如果所有结点都存在左右子树，并且叶子结点都在同一层，这样的结点称为满二叉树）
叶子结点只能出现在最下一层；只有度为0和度为2的结点

3.完全二叉树（对一颗具有n各节点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树）
1）.叶子结点只能出现在最下两层，且最下层的叶子结点都集中在二叉树左侧的连续位置
2）.如果有度为1的结点，只可能有一个，且该结点只有左孩子



**二叉树的基本性质**
二叉树的第i层上最多有2的i-1次方个结点
	分析：i= 1时，第一层上一个
		 i= 2时，第二层上两个
		 i= 3时，第三层上4个
		...
	另一种方法；第一层 1
			   第二层10
			   第三层100

在一棵深度为k的二叉树中，其结点个数最少k个，最多有2^k -1个
	分析；深度为1   最多1个
		深度为2    最多2+1=3个 = 2^2 -1
		深度为3    最多4+2+1=7个= 2^3 -1
		...
	另一种方法
		深度为1   最多1
		深度为2   最多11
		深度为3   最多111
		...

在一棵二叉树中，如果叶子结点的个数为n0，度为2的结点的个数为n2，则n0 = n2+1
（*这句话错误的理解是度为1的结点个数只有一个，这个公式只反映了度为0的结点数目和度为2的节点数目之间的关系，并没有说明度为1的结点数目*）
	证明：设n为二叉树的总结点个数，n1为其中度为1的结点个数，n2为其中度为2的结点个数
	则**n = n0 + n1 + n2**
另外一方面结合分支数目，除了叶子结点，其余结点均有向外分支，设分支数目为B，这些分支都是由度为1和度为2的结点发射，则**B = n1 + 2*n2 **
显然这样是没有结果的，再考虑特殊的根节点，除了根节点外，其余结点都有唯一的分支进入，所以对于有n个结点的二叉树，其分支结点数目为n-1，则**n  = B + 1**
于是三个式子联立求解得到 **n0 = n2 + 1 **

具有n个结点的完全二叉树的深度为【log2 n】+1
log以2为底n，向下取整，再加1

对一棵具有n个结点的完全二叉树中的结点从1开始按层序编号，则对于任意的编号为i的结点，有：
	（1）如果i>1,则结点i的双亲编号为【i/2】否则结点i是根节点，无双亲
	（2）如果2i<=n,则结点n的右孩子的编号为2i+1,否则结点i无右孩子
	（3）如果2i+1<=n,则结点i的右孩子的编号为2i+1,否则结点i无右孩子



**二叉树的存储结构及实现**
二叉树多采用二叉链表形式存储，其基本思想是令二叉树的每个节点对应一个链表结点，链表结点除了存放与二叉树结点有关的数据信息外，还要设置指示左右孩子的指针，
data、lchild，rchild
一言不合上代码

```c++
#include<iostream>
using namespace std;
template<class DataType>
struct BiNode
{
    DataType data;
    BiNode<DataType> *lchild,*rchild;
};
template<class DataType>
class BiTree
{
public:
    BiTree()
    {
        root=Creat(root);   //构造函数，建立一棵空二叉树
    }
    ~BiTree()
    {
        Release(root);   //析构函数，释放各节点的存储空间
    }
    void PreOrder()
    {
        PreOrder (root);   //前序遍历二叉树
    }
    void InOrder()
    {
        InOrder(root);   //中序遍历二叉树
    }
    void PostOrder()
    {
        PostOrder(root);   //后序遍历二叉树
    }
    void LeverOrder();                     //层序遍历

private:
    BiNode<DataType> *root;                 //指向根结点的头指针
    BiNode<DataType> *Creat(BiNode<DataType>*bt);    //构造函数调用
    void Release(BiNode<DataType>*bt);            //析构函数调用
    void PreOrder(BiNode<DataType>*bt);              //前序遍历函数调用
    void InOrder(BiNode<DataType>*bt);                //中序遍历函数调用
    void PostOrder(BiNode<DataType>*bt);            //后序函数调用
};
template<class DataType>
void BiTree<DataType>::PreOrder(BiNode<DataType>*bt)//前序遍历
{
    if(bt==NULL)
        return;           //递归调用结束的条件
    else
    {
        cout<<bt->data;     //访问根结点bt的数据域
        PreOrder(bt->lchild);       //前序递归bt的左子树
        PreOrder(bt->rchild);        //前序递归bt的右子树
    }
}
template<class DataType>
void BiTree<DataType>::InOrder(BiNode<DataType>*bt) //中序遍历
{
    if(bt==NULL)
        return;        //递归调用结束的条件
    else
    {
        InOrder(bt->lchild);       //中序遍历bt的左子树
        cout<<bt->data;           //访问根节点的数据域
        InOrder(bt->rchild);        //中序遍历bt的右子树
    }
}
template<class DataType>
void BiTree<DataType>::PostOrder(BiNode<DataType>*bt)//后序遍历
{
    if(bt==NULL)
        return;        //递归调用的结束条件
    else
    {
        PostOrder(bt->lchild);      //后续遍历b的左子树
        PostOrder(bt->rchild);            //后序遍历bt的右子树
        cout<<bt->data;           //访问根节点bt的数据域
    }
}

template<class DataType>
void BiTree<DataType>::LeverOrder()      //层序遍历
{
    int front=0,rear=0;
    front=rear=-1;   //采用顺序队列，并假定不会发生上溢
    if(root==NULL)
        return;   //二叉树为空，算法结束
    BiNode<DataType> *Q[50]= {0};
    BiNode<DataType> *q;
    Q[++rear]=root;        //跟指针入队
    while(front!=rear)      //当队列非空时
    {
        q=Q[++front];          //出队
        cout<<q->data;
        if(q->lchild!=NULL)
            Q[++rear]=q->lchild;
        if(q->rchild!=NULL)
            Q[++rear]=q->rchild;
    }
}

template<class DataType>
BiNode<DataType> *BiTree<DataType>::Creat(BiNode<DataType> *bt)   //构造函数
{
    char ch;
    cin>>ch;    //输入节点的数据信息，假设为字符
    if(ch=='#')
        bt=NULL;       //建立一颗空树
    else
    {
        bt=new BiNode<DataType>;
        bt->data=ch;       //生成一个节点，数据域为ch
        bt->lchild=Creat(bt->lchild);      //递归建立左子树
        bt->rchild=Creat(bt->rchild);        //递归建立右子树
    }
    return bt;
}
template<class DataType>
void BiTree<DataType>::Release(BiNode<DataType>*bt)    //析构函数
{
    if(bt!=NULL)
    {
        Release(bt->lchild);        //释放左子树
        Release(bt->rchild);        //释放右子树
        delete bt;            //释放根节点
    }
}
int main()
{
    cout<<"请依次输入扩展二叉树的前序遍历序列:"<<'\n';
    BiTree<char> lpl;
    cout<<"\n此二叉树的中序遍历为："<<endl;
    lpl.InOrder();
    cout<<endl;
    cout<<"此二叉树的前序遍历为"<<endl;
    lpl.PreOrder();
    cout<<endl;
    cout<<"此二叉树的后序遍历为"<<endl;
    lpl.PostOrder();
    cout<<endl;
    cout<<"此二叉树的层序遍历为："<<endl;
    lpl.LeverOrder();
    cout<<endl;
    return 0;
}

```


**测试**：输入前序扩展序列AB#D##C##，
得中序遍历：BDAC
前序遍历：ABDC
后序遍历：DBCA
层序遍历：ABCD
结果正确


需要注意的点是，**为了避免类的调用者访问BiTree类的私有变量root，在构造函数、析构函数以及遍历函数中调用了相应的私有函数，**

其中构造函数是根据一个结点序列构造一个二叉树，由于前序、中序、后序序列中的任何一个都不能唯一确定一棵二叉树，因此不能直接使用，
所以采用的方法是，将二叉树中每个节点的空指针引出一个虚结点，其值为一特定值，如‘#’，以标识其为空，把这样护理后的二叉树称为原二叉树的扩展二叉树，扩展二叉树的遍历序列能唯一确定一个二叉树，使用前序遍历序列构造。

**三叉链表**
二叉链表存储方式下，不便于寻找某个结点的双亲结点，需要从根节点开始搜索，最坏情况下，则需要遍历整个二叉链表
lchild，data，rchild，parent

**二叉树遍历的非递归算法**
非递归的前序遍历：
关键：在前序遍历过某结点的整个左子树后，如何找到该结点的右子树的根指针，
伪代码：
	栈s初始化
	循环直到bt为空，且栈s为空
	当bt不空时循环
		1.输出bt->data
		2.将指针bt保存到栈中
		3.继续遍历bt的左子树
	如果栈s不空，
	 1.将栈顶元素弹出至bt
	 2.准备遍历bt的右子树
	 
真代码：

```c++
template<class DataType>
void BiTree<DataType>::PreOeder(BiNode<DataType> *bt){
	top =-1; //顺序栈
	while(bt!=NULL || top !=-1){
		while(bt!=NULL){
			cout<<bt->data;
			s[++top] = bt; //将根指针入栈
			bt=bt->lchild;
		}
		if(top!=-1){		//栈非空
			bt=s[top--];
			bt = bt->rchild;
		}
	}
}
```


对于一棵前序遍历ABDC、中序遍历BDAC、后序遍历DBCA的树，强行画出他的结构吧，很简单的
他的非递归前序遍历详细解释如下

| 步骤 | 访问节点 | 栈s内容 | 指针bt | 解释                                                         |
| ---- | -------- | ------- | ------ | ------------------------------------------------------------ |
| 初始 |          | 空      | A      | 栈初始哈，准备遍历以A为根节点的二叉树                        |
| 1    | A        | A       | B      | 访问A，A压栈，准备遍历A的左子树B                             |
| 2    | B        | A,B     | ^      | 访问结点B，B压栈，准备遍历B的左子树，左子树为空              |
| 3    |          | A       | D      | 遍历过B的左子树，弹出栈顶元素B，找到B的右子树D，准备遍历B的右子树D |
| 4    | D        | A，D    | ^      | 访问结点D，准备遍历D的左子树^                                |
| 5    |          | A       | ^      | 遍历过D的左子树，弹出栈顶元素D，找到D的右子树^,准备遍历D的右子树^ |
| 6    |          | 空      | C      | D的右子树为空，遍历过A的左子树，弹出栈顶元素A，找到A的右子树C，准备遍历A的右子树C |
| 7    | C        | C       | ^      | 访问结点C，C压栈，准备遍历C的左子树^                         |
| 8    |          | 空      | ^      | 遍历过C的左子树，弹出栈顶元素C，找到C的右子树^,准备遍历C的右子树^ |
| 9    |          | 空      | ^      | 此时栈为空，且根指针也为空，遍历结束                         |

上表详细分析了二叉树前序遍历的执行过程，访问完该节点以后，应该将结点的指针保存在栈中，以便以后能找到该结点的右子树。


非递归的中序遍历：
	中序遍历中，访问结点的操作发生在该结点的左子树遍历完毕并准备遍历右子树的时，所以遇到某节点先将它压栈，等到他的左子树遍历完毕的时候，再从栈中弹出并访问


非递归的后序遍历：
	后序遍历结点要入栈两次，出栈两次
伪代码：
栈s初始化
循环知道bt为空且栈s为空
	当bt非空时循环
		将bt连同标志flag=1入栈
		继续遍历bt的左子树
	当栈s非空且栈顶元素标志为2时，出栈并输出栈顶结点
	若栈非空，将栈顶元素标志改为2，准备遍历栈顶结点的右子树
	

------------

*2019-03-17 16:53:02 星期日
萧逸小杨*

