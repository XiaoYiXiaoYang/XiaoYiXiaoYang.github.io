---
title: C++基础（自定义数据类型、指针、数组）
date: 2019-12-08 18:58:01
tags: [C++]
categories: [学习笔记]
---

 分享数组等学习及练习题

<!--more-->

#### 数组

声明数组的方式

```c++
int a[5] = {0}; 全部赋初值0,
int a[5] = {1,2,3} 前3个数组元素为1,2,3，后两个数组元素为0
int a[] = {1,2,3,4,5}	数组元素个数由括号内数据个数确定
```

数组的长度必须是确定的，数组元素在内存中是顺序、连续存储的
（若定义数组时没有指定任何一个数组元素的初值，对于静态生存期的数组，每个数组元素仍然被赋予0值，对于动态生存期的数组，每个元素的初值还是不确定）

（一维数组的元素按下表从小到大的顺序连续存放在计算机内存单元中，）

多维数组
二维数组f[3][3]
可以把f[0]看作一维数组名，则f[0][0]、f[0][1] 、f[0][2]构成了一维数组的3个元素，
（二维数组按行优先的次序存储）

**数组作为函数参数**

数组名是数组首元素的地址，参数传递直接把地址传递给形参，使形参和实参指向同一内存地址，如果修改会把原数组值改变

函数声明形式
void f(int a[],int n); 	适用于处理不同长度的数组，数组的实际长度通过另一个参数传递给函数
void f(int a[5]);   只可传递长度固定的数组



**对象数组**

（数组元素是对象，不仅有数据成员，还有函数成员）
对象数组初始化，实际上就是调用构造函数对每一个元素进行初始化的过程，如果在生命数组时给每一个数组元素指定初始值，在数组初始化过程中就会调用与形参类型匹配的构造函数
Location a[2]={Location(0,0),Location(1,2)};
如果没有指定数组元素的初值，就会调用默认构造函数
Location a[2]={Location(1,2)}   //初始化了a[0]，a[1]会被调用默认构造函数



**数组与字符串**

```c++
char a[] = "iamaboy";
char a[]={'i','a'};
char a[]={"iamaboy"};  //末尾加'\0'
```




#### 自定义数据类型

**typedef**

为一个已有的数据类型另外命名
typedef 已有类型名 新类型名



**结构体**

```c++
struct Students{
	char name[20];
}
声明方式
1.Students stu1;
2.struct Students stu1;
3.struct Students{
	char name[20];
}stu1,stu2;
```



**共用体**

同一段内存空间存储不同类型的数据，共用体中的成员所占用的空间是共享的，这样对其中一个成员的赋值，将会影响到其他所有成员的值

```c++
union UnionDate{
	int data；
	char cchardata；
	float cfloatdata；
}MyUnion；
MyUnion.data = 64；
```

这样会影响另外两个成员的值，cchardata与data的前一个字节相同，cfloatdata与data的前4个字节相同



这样会影响另外两个成员的值，cchardata与data的前一个字节相同，cfloatdata与data的前4个字节相同

**枚举类型**

enum Days{Sun,Mon,...}；
枚举元素按常量处理，不能赋值
每一个枚举变量对应一个整数，从0开始递增， 中间的也可以自己指定，后面没指定的则从前一个指定的开始增1作为它的整数



#### 指针（指针就是指向某个内存单元的地址值）



**void型指针**（可以存储任何类型的对象地址，就是说任何类型的指针都可以赋值给void型指针变量，经过使用类型显式转换，通过void类型的指针便可以访问任何类型的数据）

```c++
void *pv=&i;  //声明void类型指针指向int型变量
int *pint = static_cast<int *>(pv);  //void型指针赋值给int型指针
```



**空指针NULL**（安全起见，不指向任何地方）

1.int i=5,*p;	p = &i;
2.int i =5;		int *p = &i

**指针的算术运算**(指针和整数加减、指针和指针相减=两个地址间的相对距离)
**指针的关系运算**(内存地址的关系运算)



**常量指针**：声明*指向常量的指针*，此时不能通过指针来改变所指对象的值，但是指针本身的值可以改变，可以指向另外的对象
const int *p1 = &a;
p1 = &b;



**指针常量**：*指针类型的常量*，这时指针本身的值不能被改变
int *const p2 = &a;
（数组名实际是一个不能被赋值的指针，也就是指针常量，）



**指针处理数组元素**
int array[10]
int *p = &array[0]

*array = array[0]，*(array+5) = array[5]，*(p+5) = p[5]



**指针数组**（数组的每一个元素都是类型相同的指针变量）
int *array[6]; 	//6个int *型元素的指针数组
int (*array)[6];  //6个int型元素的数组



**多维数组**
**多维数组的数组名同样是个指针，但是它不指向多维数组的第一个元素的地址 &array[0][0],它指向的是存放第一个数组元素的地址的地址******

二维数组array[3][4]
array[0] = &array[0][0]  array[0]看成一维数组名

那么array = &array[0]    还是看成一维数组

```
	int line1[ ]={1,0,0};    //声明数组，矩阵的第一行
	int line2[ ]={0,1,0};    //声明数组，矩阵的第二行
	int line3[ ]={0,0,1};    //声明数组，矩阵的第三行
	int *pLine[3];	    //声明整型指针数组
	pLine[0]= line1;	//初始化指针数组元素
	pLine[1]= line2;
	pLine[2]= line3;
```

**多级指针**
int i=5; int *p =&i;	int *pp = &p;

**指针变量作为函数参数**( 形参发生改变，直接会改变实参值)
(传递指针减少开销，提高效率)

**指向函数的指针**（**函数名是指针，是函数入口地址**）、

**指针作为函数的返回类型**（char * fun()）



**动态分配内存**
new运算便返回一个指向新分配内存首地址的类型的指针，可以通过指针对**堆对象**进行访问
int *p = new int;   //不设初值
int *p = new int(2);   //设初值2

delete用来删除new建立的对象，释放指针所指向的内存空间
如果删除的是对象，则该对象的析构函数被调用，
如果是new建立的数组，delete删除时在指针名前面要加“[]”

new建立的对象，delete只能删一次，多次删除同一内存空间会导致运行错误

注意：new 创建多维数组
new 类型名T[第一维长度][第二维长度]..
如果申请成功，new运算返回的值一个指向新分配内存的首地址的指针，但不是T类型的指针，而是一个指向T类型数组的指针，数组元素个数为除最左边一维外各维下标表达式的乘积
float *fp;
fp = new float[10][25][10];  //出错

正确写法为 
float (*cp)[25][10];
cp = new float[10][25][10];

```c++
	int (*cp)[3];
	int i,j;
	cp = new int[2][3];
	for (i=0; i<2; i++)
		for (j=0; j<3; j++)
			    *(*(cp+i)+j)=i*10+j;  //通过指针访问数组元素
		for (i=0; i<2; i++) {
			for (j=0; j<3; j++) {	//通过数组名和下标访问数组元素
				cout<<cp[i][j]<<"  ";  //将指针cp作为数组名使用，
			}
			cout<<endl;
		}
		
		delete[] cp;
```



**用vector创建数组对象**
vector<int> arr(10);  //定义了10 个int型数组，每个数组元素都被赋值为0
vector<int> arr(10,2);  //定义了10 个int型数组，每个数组元素都被赋值为2



**深复制与浅复制**
浅复制(两个指针指向的是同一块内存地址，表面上好像完成了复制，但是并没有形成真正的副本)
弊端：程序结束之前，动态分配的内存通过析构函数释放，由于两个对象共用了同一块内存空间，因此该空间被两次释放，导致运行错误

深复制（自己写深复制代码，新开辟内存，让两个对象不再共用同一块内存空间）



------------

*2019-03-14 17:02:29 星期四
萧逸小杨*