---
title: C++ primer（第三章 字符串 向量 数组）
date: 2019-12-14 22:40:23
tags: [C++ Primer]
categories: [学习笔记]
---

 string 和vector标准库类型

<!--more-->

#### 3.1 命名空间using声明

头文件不应该包含using声明

头文件的内容会拷贝到所有引用他的文件中去，如果头文件里有using声明，那么每个使用了该头文件的文件就会有这个声明，对某些程序来说会产生名字冲突

#### 3.2 标准库类型string

定义和初始化string对象
string对象上的操作
处理string对象中的字符


```
#include<string>
```

直接初始化：不使用 =，则执行的直接初始化
拷贝初始化： 使用等号（=）去初始化一个变量，实际上执行的是拷贝初始化


标准库string类型的cin操作是从第一个非空白字符开始读取，直到读取到下一个空白字符为止，比如输入“   hello world   ”，则输出hello。

如果想读取一整行，则需要用函数getline函数替换>>运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读取内容， 直到遇到换行符为止（**注意：换行符也被读进来了**），**然后把所读的内容存入到那个string对象中去（注意：不存换行符**）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始就输入换行符，则输出一个空string对象。

string类的size函数返回string对象的字符数，其返回值是string::size_type类型，它是一个无符号整型的值（string s，s.size()）。可以使用auto来推断变量的类型：`auto len = s.size();`。需要谨慎其与int类型的数的比较。


字面值和string对象相加
当把string对象和字符字面值及字符串字面值(字符串字面值与string是不同的类型)混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。

```
string s1 = "hello";
string s2 = s1 + ", ";    //正确，把一个string对象和字面值相加
string s3 = “hello” + “, ”+s1;//错误，+号两侧是字符串字面值
string s4 = s1+ “, ”+ "world\n";   //正确，s1+“， ”是string
```

处理string对象中的字符
范围for语句用于遍历给定序列中的每个基础元素并对序列中的每个值执行某种操作，其语法形式是：
```
for(declaration : expression)
    statement
```

使用范围for语句和ispunct函数来统计string对象中标点符号的个数

```
string s("hello world!!");

decltype(s.size()) num=0;  //punct类型和s.size的返回类型一样

for(auto c:s)
	if(ispunct(c))
		++num;
cout<<num<<endl; 
```

使用范围for语句改变字符串中的字符（把循环变量定义成引用类型）

```
for(auto &c:s)
	c = toupper(c);  //c是一个引用，所以赋值语句改变s中字符的值
```

使用下标

```
for(decltype(s.size() index=0;
index !=s.size() && !isspace(s[index]);
++ index)
{
  s[index] = toupper(s[index]);  //将当前字符改成大写形式
}
```

**使用迭代器**


#### 3.3 vector（容器）

定义和初始化vector
添加元素
其他操作

vector是一个类模板，在模板名字后面跟一对尖括号，在括号内放上信息
vector能容纳大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector

早期C++版本中如果vector的对象还是vector则定义时需要在外层vector对象的右尖括号和其他元素类型之间添加一个空格，vector<vector<int>[空格]>


列表初始化vector对象
值初始化vector对象

```
vector<string> v1{"a","b","c"};  //列表初始化
vector<int> ivec(10);            //10个元素，都初始化为0
```


第一，使用拷贝初始化时，只能提供一个初始值
第二，如果提供的是一个类内初始值，则只能使用拷贝初始化或者使用花括号的形式初始化
第三，如果提供的是初始元素值的列表，则只能把初始值都放在花括号内进行列表初始化，而不能放在圆括号里


列表初始值还是元素数量?

```
vector<int> ivec;  //空的vector
vector<int> v1(10,0);  //10个元素，每个都是0  圆括号
vector<int> v2{10};  //有一个元素，值为10   花括号
```

如果用的是圆括号，可以说提供的值用来构造vector对象
如果使用的是花括号，可以表述成我们想列表初始化该vector对象

```
vector<string> v1{10};  //10个元素，每个都是0  花括号
vector<string> v2{10，“hi”};  //有10个元素，值为‘hi’   花括号

要想列表初始化vector对象，花括号里的值必须与元素类型形同，显然不能用int初始化string对象，所以v1和v2提供的值不能作为元素的初始值
确认无法执行列表初始化后，编译器尝试用默认值初始化vector对象
```

**向vector中添加元素**

先创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素

如果循环体内含有向vector加元素的语句，则不能使用范围for循环

范围for循环语句体内不应改变其所遍历序列的大小

**其他vector操作**

vector对象的下表也是从0开始，下标的类型是相应的size_type类型

vector对象和string对象的**下标运算符**可用于访问已存在元素，**不能用于添加元素**


####  3.4 迭代器

使用迭代器
迭代器计算

迭代器，其对象是容器中的元素或string对象中的字符，使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素，迭代器有有效和无效之分，
有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置，其他所有情况都属于无效

begin()   指向第一个元素   
end()    指向最后一个元素的下一个位置叫（尾迭代器或尾后迭代器）

如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器

迭代器相等----两个迭代器所指的元素相同或者都是同一个容器的尾后迭代器

迭代器+1----将迭代器“向前移动一个位置”

**迭代器类型**

iterator				对象不是常量
const_iterator			对象是常量

```
*(it).empty();			//*运算符和.运算符
```

限制1.不能在范围for循环语句中向vector添加元素
限制2.任何一种可能改变vector对象容量的操作，都会使该vector对象的迭代器失效

**解引用和成员访问操作**

解引用可得到迭代器所指的对象
箭头运算符把解引用和成员访问两个操作结合在一起

```
it->mem
(*it).mem
```
**迭代器运算**

| 迭代器      | 运算                                 |
| ----------- | ------------------------------------ |
| iter+n      | 迭代器加上一个数值仍得一个迭代器     |
| iter1-iter2 | 两个迭代器相减的结果是它们之间的距离 |


#### 3.5 数组


定义和初始化内置数组
访问数组元素
数组和指针
C风格字符串
与旧代码接口


```
int a[d];  //a是数组名，d是数组维度
```

维度必须是一个常量表达式

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型，另外和vector一样，数组的元素应为对象，因此不存在引用的数组

字符数组（末尾带结束符'\0'）

不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值

```
int a[]={1,2,3};
int a2=a;   //错误
a2=a;  //错误
```

**复杂的数组声明**

定义数组的指针和数组的引用

```c++
int *ptrs[10];   //ptrs是含有10个整型指针的数组
int &refs[10]=/*?*/;  //错误，不存在引用的数组
int (*Parray)[10] = &arr;  //parray指向一个含有10个整数的数组
int (&arrref)[10] = arr;   //arrref引用一个含有10个整数的数组

//ptrs从右向左，大小为10的数组，他的名字是ptrs，数组存放的是int型指针
//Parray由内向外，圆括号括起来的部分*parray意味着parray是个指针，右边看出parray是个指向大小为10的数组的指针，最后左边数组中元素是int
```

数组下标 size_t类型

**指针和数组**

**使用数组的时候，编译器一般会把它转换成指针，
在很多用到数组名的地方，编译器会把它转换成指向数组首元素的指针**

在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

**则使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组**

**当使用decltype时不会发生转换，decltype(ia)得到的是数组而不是指针**

```
int ia[]={1,2,3,4,5,6,7};
auto ia2(ia)  //ia2是一个整形指针，指向ia的第一个元素
decltype(ia) ia3={1,2,3,4,5};  //ia3是一个数组
```

**指针也是迭代器**

迭代器的运算，数组的指针全都支持，

获取尾后指针有些特殊

```
int arr[]={1,2,3}
int *p=&arr[3];
```

**标准库函数begin和end**

```
int *beg =begin(ia);   //首指针
int *last=end(ia);     //尾后指针
```

指针相减得到ptrdiff_t的标准库类型，在头文件cstddef中

**解引用和指针**

```
int last = *(ia+4);  //ia地址前进四个元素后的新地址，解引用它

last =*ia+4；     //先解引用，再给解引用的元素值+4
```



**C风格字符串**

```
char a[] ={'a','b','c'};   //列表初始化 没有空字符

char a[]="ac";   //末尾自动添加空字符
```

| strlen(p)     | 返回p的长度，空字符不计算在内                                |
| ------------- | ------------------------------------------------------------ |
| strcmp(p1,p2) | 比较p1和p2的相等性，如果p1==p2,返回0，如果p1》p2，返回1个正值，如果p1《p2，返回一个负值 |
| strcat(p1,p2) | 将p2附加到p1之后，返回p1                                     |
| strcpy(p1,p2) | 将p2拷贝给p1，返回p1                                         |
|               | 上述函数不负责验证其字符串参数                               |
|               | 传入此类函数的指针必须以指向空字符作为结束的数组             |



**混用string对象和c风格字符串**

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

1. 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。

2. 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

上述结论反过来就不成立了：如果程序的某处需要一个C风格字符串，无法直接用string对象来替代它。例如不能用string对象直接初始化指向字符的指针。不过string专门提供了一种方法来完成该功能：一个名为c_str的成员函数。

```
string s("hello world");
char *str = s;    //错误，不能用string对象初始化char*
const char *str = s.c_str();    //正确
```

可以看出，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char* ，从而确保不会改变字符数组的内容。



**使用数组初始化vector**

不允许使用一个数组为另一个内置类型的数组赋初值，
不允许使用vector对象初始化数组

允许使用数组初始化vector对象

```
int arr[] ={1,2,3,4};

vector<int> ivec(begin(arr),end(arr));  //指明拷贝区域的首指针和尾后指针
```



#### 多维数组


初始化

```
int ia[3][4]={{0},{4},{8}};   //显式的初始化每行首元素

int ix[3][4]={0,3,6,9};       //显式的初始化第一行
```

引用

```
int (&row)[4] =ia[1];  //把row绑定到ia的第二个4元素数组上
```
把row定义成一个含有4个整数的数组的引用，然后将其绑定到ia的第二行

范围for语句处理多维数组

```
size_t cnt = 0;

for(auto &row :ia)			//对于外层数组每个元素
	for(auto &col :row){    //对于内层数组每个元素
		col =cnt;           //将下一个值赋给钙元素
		++cnt;              //cnt+1
	}
```

因为要改变元素值，所以声明row，col为引用
第一个for循环遍历ia的所有元素，这些元素是大小为4的数组
第二个for循环遍历4个元素数组中的某有一个，col的类型是整数的引用

声明成引用类型，这是为了避免数组被自动转换成指针

```
for(auto row :ia)
	for(auto col :row)
程序将无法通过编译，
row不是引用类型，编译器初始化row会自动讲这些数组形式的元素转换为指向数组内首元素的指针，则row的类型是int *，则内层循环不合法
```



**指针和多维数组**

```
int *ip[4];    //整型指针的数组
int (*p)[4];   //指向含有4个整数的数组
```

```
for(auto p=ia;p != ia+3;++ p){
	for(auto q=*p;q != *p+4;++q)
		cout<<*q<<"";
}
```

外层for循环声明一个指针p，并令其指向ia的第一个内层数组，然后依次迭代3行
内层for循环令指针q指向p当前所在行的第一个元素，*p是一个含有4个整数的数组，数组名被自动转换成指向数组首元素的指针，



------------