---
title: C++ Primer(第七章 类)
date: 2019-12-15 14:11:05
tags: [C++ Primer]
categories: [学习笔记]
---

数据抽象和封装，依赖于接口和实现

<!--more-->



#### 定义抽象数据类型



**引入this**

当我们用对象调用函数的时候，this指针会被初始化

则在成员函数内对数据成员的访问都被看做this的隐式引用



**引入const成员函数**

const成员函数的作用是修改this指针的类型

意味着this指针的类型是指向类类型非常量版本的常量指针，在成员函数内不能修改对象成员的值

意味着不能把this指针绑定到一个常量对象上，则一个常量对象不能调用普通的成员函数

这样的函数叫做**常成员函数**



**类作用域和成员函数**

成员的声明在函数的后面，但是还能使用

因为编译器先编译成员的声明，然后才轮到成员函数体。成员函数体可以随意使用类中的成员而无须在意成员出现的次序



**在类的外部定义成员函数**

成员函数的定义必须和成员函数的声明保持一致



**定义一个返回this对象的函数**

return *this;



**构造函数**

构造函数不能是const的，当我们创建一个const对象时，直到构造函数初始化完成，对象才能真正取得“**常量**”属性



**合成的默认构造函数**

假象：没有为类显式的定义一个构造函数，则编译器隐式的定义一个默认构造函数



**某些类不能依赖于合成的默认构造函数**

原因1.一旦我们定义了自己的构造函数，则编译器不会帮我们合成

原因2.合成的默认构造函数可能执行错误的操作

- 如果类内包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类內初始值时，这个类才适合于使用合成的默认构造函数

原因3.有的时候编译器不能为某些类合成默认构造函数，如果类中包含其他类类型成员，而该类没有默认构造函数，则编译器无法初始化该成员



**=default**

要求编译器生成构造函数



**拷贝、赋值和析构**

管理动态内存的类一般不能依赖于上述操作的合成版本

而使用vector或string的类能避免分配和释放内存带来的复杂性





#### 访问控制与封装



**友元**

友元会破坏封装



#### 类的其他特性



**可变数据成员**

通过在变量的声明中加入mutable关键字

```c++
class S
{
    mutable int a;		//即使在一个const对象内也能被修改
};
```



**返回*this的成员函数**

返回的是A&类型



**从const成员函数返回*this**

一个const成员函数如果以引用形式返回*this，那么他的返回类型将是常量引用



**基于const的重载**

函数是不是const的可以重载



**友元再探**

友元类的成员函数可以访问此类包括非公有成员在内的所有成员



#### 类的作用域

一个类就是一个作用域



函数的返回类型通常出现在函数名之前，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外，这时，返回类型必须指明它是哪个类的成员





#### 构造函数再探



成员初始化顺序，与初始化列表无关，和成员在类內声明的顺序一致



**委托构造函数**

使用成员初始值列表，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

```c++
class S
{
    S(string s,int cn,double price):bookNo(s),unit_sold(cn),revenue(price){}
    S():S("",0,0){}   //使用了委托构造函数
};
```



**默认构造函数的作用**



默认初始化在以下情况发生

- 当我们在块作用域内不适用任何初始值定义一个非静态变量或数组时
- 当一个类本身含有类类型的成员且使用和合成的默认构造函数时
- 当类类型的成员没有在构造函数初始值列表中显式地初始化时

值初始化在以下情况发生

- 在数组初始化过程中如果我们提供的初始值数量少于数组的大小时

- 当我们不适用初始值定义一个局部静态变量时
- 当我们书写形如T()的表达式显式的请求值初始化时



**隐式的类类型转换**

编译器只会自动的执行一步类型转换



**抑制构造函数定义的隐式转换**

explicit关键字

explicit构造函数只能用于直接初始化



**聚合类**

- 所有成员都是public
- 没有定义任何构造函数
- 没有类內初始值
- 没有基类，也没有虚函数



满足以上的是聚合类

可以使用花括号括起来的初始值列表初始化



**字面值常量类**

constexpr函数的参数和返回值必须是字面值类型



数据成员都是字面值类型的聚合类是字面值常量类

如果一个类不是聚合类，但他符合下列要求，则也是字面值常量类

- 数据成员必须是字面值类型
- 类必须至少含有一个constexpr构造函数
- 如果一个数据成员含有类內初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果属于某种类类型，则初始值必须使用成员自己的constexpr函数
- 类必须使用析构函数默认定义，



**constexpr构造函数**

通过前置关键字constexpr声明

constexpr构造函数必须初始化所有数据成员，初始值或使用constexpr构造函数，或者是一条常量表达式





#### 类的静态成员



静态成员函数不含this指针

静态成员可以是不完全类型





