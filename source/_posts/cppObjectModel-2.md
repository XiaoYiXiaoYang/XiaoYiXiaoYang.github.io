---
title: C++对象模型(构造函数语意学)
date: 2019-12-13 22:05:05
tags: [C++对象模型]
categories: [学习笔记]
---





implicit：隐式的

explicit：显式的

trivial：没有用的

nontrivial：有用的

memberwise：对每一个member施以...

bitwise：对每一个bit施以...

semantics：语意

<!--more-->



#### 默认构造函数Default Constructor



默认构造函数是编译器的需要所产生的



```c++
class Foo
{
  int val;
  int *pnext; 
};

void foo_bar()
{
    Foo bar;
    if(bar.val)
    {
        
    }
}
//正确的程序语意要求Foo类有一个默认构造函数，能将两个成员变量初始化为0，
//但是这是程序的需要，不是编译器的需要，编译器不会产生这样的默认构造函数

```



```c++
class Foo
{
public:
    	Foo();
private:
  int val;
  int *pnext; 
};

class Bar
{
 public:
    Foo foo;
    char *str;
};

void foo_bar
{
    Bar bar;
    if(bar.str)
    {
        
    }
}

//Bar 类内含Foo类对象成员，且Foo类有默认构造函数，所以编译器会为Bar类生成一个默认构造函数
```





1.带有默认构造函数的类成员

2.带有默认构造函数的基类

3.带有一个虚函数的类

4.带有一个虚基类的类





#### 拷贝构造函数Copy Constructor



被调用的时机

1.显式的以一个对象的内容作另一个对象的初值

X xx = x;



2.函数参数是类对象，形参与实参结合的时候



3.函数返回值





**默认的对每一个成员初始化**



当一个类没有提供显式拷贝构造函数，而该类的一个对象以另一个对象作为初值时，内部以对每一个成员初始化的手法完成。

把每一个内建类型的数据的值拷贝到另一个对象

但是不会拷贝类对象，而是递归的方式对类对象内部再拷贝



#### 位逐次拷贝语意



当一个类表现出位逐次拷贝语意时，其不需要编译器生成拷贝构造函数



#### 不展现位逐次拷贝语意

1.当一个类内含类成员，而成员的类声明有一个拷贝构造函数时

2.当类继承自一个基类，而该基类存在一个拷贝构造函数的时候

3.当一个类声明了一个或多个虚函数

4.当一个类派生自一个继承链，其中有一个或多个虚基类



上述编译器会合成拷贝构造函数，1、2情况下，

1.编译器将成员的拷贝构造函数代码安插到被合成的拷贝构造函数中。

2.编译器将基类的拷贝构造函数代码安插到被合成的拷贝构造函数中。

3.声明虚函数的类的默认拷贝构造函数需要**增加一个虚函数表**，内含虚函数；然后**重新设定虚函数表的指针vptr**

4.编译器让**派生类对象中的虚基类子对象的位置在执行期就准备妥当**。安插一些代码以设定虚基类指针的初值，对每一个成员执行必要的按位拷贝操作，以及执行其他 的内存相关操作。





#### 程序转化语意学



**显式的初始化操作**



```c++
void foo()
{
	X x1(x0);
    X x2 = x0;
    X x3 = X(x0);
}


1.重写每一个定义
2.安插拷贝构造函数代码
```



**参数的初始化**

生成临时量，调用拷贝构造函数，将临时量交给函数



**返回值的初始化**

NRV优化：named return value

直接将返回值作为第一参数传入，编译器层面的优化



*即使编译器能合成拷贝构造函数，但是程序中需要的地方还是要显式的声明，因为编译器并没有合成的地方可能不是程序员本身的意思，另外即使编译器合成了拷贝构造函数也不是程序员的意愿，充分了解编译器的优化才能掌握程序的效率。*



#### 初始化列表



1.当初始化一个引用成员时

2.当初始化一个常量成员时

3.当调用一个基类的构造函数，而它拥有一组参数的时候

4.当调用一个成员的构造函数，而它拥有一组参数的时候



这些情况是使用初始化列表比较有意义的时候

编译器能快速初始化那些需要初始化的参数



但是注意：初始化列表顺序不是编译器执行顺序，编译器按照成员在类内声明顺序初始化

