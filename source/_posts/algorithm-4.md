---
title: 算法入门----（数学问题）
date: 2019-12-15 20:02:26
tags: [算法]
categories: [学习笔记]
---

 算法设计需要良好的数学素养，特别是利用计算机解决具体问题的数学思维素养

<!--more-->

**概述**

阿波第一个登上飞机，随便找了个位子坐下，乘客们也都随意找了位置坐下来，问第i个乘客（除去阿波）坐到原机票位置的概率是多少？
n表示共n个乘客  m表示第m个乘客

分析：前m-1个人是关于n-1个位置全排列的情况下，第m个人就能坐到他自己的位置上了，而所有的情况是m个人对于n个位置的全排列。前m-1个人都没坐在第m-1个人的位子的概率为
	P =n-1/n * n-2/n-1 * ... * n-m+1/n-m
第一个人除了第m个位子 都可以坐 
第二个人除了第一个人的和第m个位子，都可以坐
...
第m-1个人除了前m-2个位子和第m个位子，都可以坐

第m个人恰好坐在自己位子上的概率为
	P * 1/n-m+1 = 1/n

**同余**

辗转相除法求最大公约数

```
int gcd(int a,ing b){
	while(b>0){
	int r=b;
	b=a%b;
	a=r;
	}
	return a;
}
```

```
int gcd(int a,int b){
	if(b==0) return a;
	else	return gcd(b,a%b);
}
```

求一个很大的数对73取模

大数用字符串读入，nd nd-1 ...n2 n1 
(nd nd-1 ...n2 n1 )mod m = (nd * 10^d-1) mod m +..+(n2*10) mod m + n1  mod m

```
char a[100000000];
int main(){
	while(scanf("%s",a)!=EOF){
	int ans=0;
	int len = strlen(a);
	for(int i=0;i<len;i++){
	ans = ((ans*10)+(a[i]-'0')) %m;
	}
	}
}
```

计算a^b mod c
积的取余等于取余的积的取余
快速取幂法 

```
int main(){
	int a,b,c,mod;
	cin>>a>>b>>c;
	mod =a;
	for(int i=1;i<b;i++){
	mod = (mod * a)%c;
	}
	cout<<mod<<endl;
}
```

青蛙约会
青蛙A出发点x，青蛙B出发点y，青蛙A每次跳m米，青蛙B每次跳n米，纬度线总长L米
问跳多少次后碰面？

列方程
设t步，(x+m*t)-(y+n*t) = p*L 
p为整数

进制转换
损坏的里程表，不能显示数值4，会从数字3直接跳到数字5
先将这个数转换为真正的9进制数，所有大于5的数字减一，然后将9进制转换为十进制

**素数**

素数筛选法
建立一个较大的数组isPrime[]，初始化所有下标为奇数的为true，下标为偶数的为false,然后筛选

```
bool isPrime[100001];

void getprime()
{
    int len = sizeof(isPrime)/sizeof(isPrime[0]);
    isPrime[2]=true;
    for(int i=3; i<len; i+=2) isPrime[i]=true;
    for(int i=4; i<len; i+=2) isPrime[i]=false;

    for(int i=3; i<sqrt(len); i++)
    {
        if(isPrime[i])
        {
            for(int j=i+i; j<=len; j+=i)
                isPrime[j]=false;
        }
    }
}
int main()
{
    getprime();
    for(int i =1; i<101; i++)
    {
        if(isPrime[i])
            cout<<i<<"\t";
    }
    return 0;
}
```

**组合问题**

错排：一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为错排,n个元素的错排数记为D(n)
D(n) = (n-1)(D(n-2)+D(n-1))

每个人写一张纸条放入盒子，然后每人从盒子中拿出一个纸条，如果纸条上就是自己的名字，那就算中奖了，求所有人都没有中奖的概率，

最后一个人没有中奖的概率为D(n)/n!

```
void init(){
	A[1]=D[2]=1;
	A[2]=1;
	for(ll i=3;i<N;i++){
		A[i] = A[i-1]*i;
		D[i]=(i-1)*(D[i-1]+D[i-2]);
	}
	for(int i=2;i<N;i++)
		ans[i]=1.0*D[i]/A[i]*100.0;
}
```

组合公式

n个里面选m个 Cn m = n！/(n-m)!* m!
C6 4 = 6*5*4*3/4*3*2*1

**概率问题**

（概率论）

期望

有n条绳子，n为偶数，平行放置一排，在两头分别打n/2次节，且使用过的不能再使用，问最终使得所有绳子连接成一个大圈的概率

...没懂  n-2/n-1 * n-4/n-3 *..* 2/3


A和B之间有n条河，A和B相距D，河宽Li，每条河上有一个速度为Vi的船，在河上来回行驶，每条河离A的距离为Pi，设步行速度始终为1，现在求从A到B时间的期望

如果全部步行则期望为D
如今每遇到一条河，求过河时间的期望，等待时间的区间为(0，2*L/v)。船在每一个地方都是等可能的。所以等待的期望就是(0 + 2*L/v) / 2 = L / v，又过河还要L / v，所以总的渡河期望值为2 * L / v。
所以每遇到一条河拿D减去如果步行过河的期望L再加上实际过河期望2 * L / v就可以

每个人都有自己的生日，如果一群人站在一起，那么他们有至少两个人生日相同的概率是多少？
题意给出一年的时长（一年不一定365天） 需要选出多少人才能使得概率不低于0.5

p(i) 表示i个人但是没有人同时生日的概率，则P(1) = 1
P(i) = 365/365 * 364/365 *..*365-i+1/365  
当P(i) <=0.5 时，至少有两个人同时生日的概率为1-p(i) >=0.5

一个人去邮局寄东西，邮局柜台有N个客服，编号为1-N，且此时每个客服柜台前都有且仅有一个客户在服务，哪个客户先服务完，此人就可以直接进入服务

每个客户的服务效率为Ki 
i表示第i个客服
已知每个客服的服务时间满足一定的分布，并且已知每个客户已被服务的时间为ci
求此人需要等待时间的时间期望

每个服务员是独立的，可以先求出等待时间的期望是 1/k1+k2+...+kn
对于每个服务员，选择的概率为ki/k1+k2+...+kn
该服务员期望的服务时间为1/ki，于是期望的服务时间为：...





------------

*2019-04-10 14:27:41 星期三
萧逸小杨*