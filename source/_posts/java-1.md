---
title: Java基础（数组、字符串）
date: 2020-01-08 16:22:21
tags: [JavaWeb]
categories: [学习笔记]
---

一个纯面向对象的语言，优势非常明显，不得不了解

<!--more-->

**面向对象的语言**

程序=对象+消息
程序=数据结构+算法

**Java的特性**

Java还是主要从C++学习并改写了一些内容，去除指针机制等等，所以很多特性是相对于C++来说的。

1.简单性
Java语言风格类似C++，保留了C++的优点，摒弃了C++中不安全且易引发错误的指针，消除了操作符重载、多重继承、数据类型自动转换，简化了内存管理和文件管理，Java提供了自动内存垃圾收集机制，但是增加了系统运行时复杂性，需要内嵌一个内存管理模块，

2.面向对象
面向对象和面向过程是一个巨大的转变，面向过程是从问题的解决办法着手，面向对象是从问题的属性和行为着手。

3.平台无关性
C++代码编译--》目标文件.obj--》链接--》.exe可执行文件--》操作系统
所以c++源码在换平台后，其源码需要重新编译才能被操作系统运行。

Java编译器--》字节码文件.class--》JVM虚拟机
这里虚拟机起了重要作用，有windows下的JVM虚拟机，linux下的虚拟机，只要有虚拟机，Java程序可以在任意操作系统内的JVM上执行，最终是由JVM虚拟机解释运行，和操作系统无关，
Java源码先编译，后被虚拟机解释运行，所以称Java既是编译型的又是解释型的

4.高性能
a.高效的字节码，Java字节码经由JVM的解释器解释执行生成高效的机器码，据统计，Java编译器生成的字节码和机器码执行效率相差无几，且其字节码的执行效率非常接近于C/C++生成的机器码的执行效率

但是这一点在acm中，通常允许java语言执行的时间是C/c++的2倍，这也是语言本身的特性

b.多线程，C++是单线程的体系结构

c.及时编译和嵌入c代码

5.分布式
数据分布：数据可以分散存放于网络上不同主机中，解决海量存储问题
操作分布：把计算分散到不同主机上进行处理

6.动态特性
Java采用动态链接机制，系统由多个模块组成，每个模块分别编译成各自的字节码文件，系统运行时按照程序运行的需要动态装载，当修改了某个类，只需要对这个类重新编译，其他类无需重新编译

7.健壮性和安全性
Java设计目的用于网络/分布式计算环境
a.java语言本身的安全性设计
提供数组下标越界检查，异常处理，自动内存垃圾收集
b.编译检查 编译期间不分配内存，在运行时由解释器决定
c.运行检查 
字节码校验器： Java字节码进入解释器，即使生成的是完全正确的字节码，解释器也必须再次对其进行检查，防止解释执行前被改动
运行时内存布局和类装载器：解释器将决定程序中类的内存布局，无法预先得知一个类的内存布局结构
文件访问限制：限制网络上装载的类智能访问某些允许的文件系统
d.网络接口级的安全检查

**Java语言基础**

| 关键字  | 字节数 |
| ------- | ------ |
| byte    | 1      |
| short   | 2      |
| int     | 4      |
| long    | 8      |
| float   | 4      |
| double  | 8      |
| char    | 2      |
| boolean | 1      |

主要就是这最后一项，char类型为2个字节，为了统一汉字编码

强制类型转换
a.隐式类型转换
（byte 或者 short） 与int型运算，转换为int型
（byte 或者 short 或 int） 与long型运算，转换为long型
（byte 或者 short 或 int 或 long） 与float型运算，转换为float型
（byte 或者 short 或 int 或 long 或 float ） 与double型运算，转换为double型

Java不允许隐式把double转换为int

b.显式类型转换
int i; float h=9.6;
i = (int)h;

位运算

| 运算符 | 含义       |
| ------ | ---------- |
| ~      | 取反       |
| 单竖杠 | 或         |
| &      | 与         |
| ^      | 异或       |
| <<     | 左移       |
| >>     | 右移       |
| >>>    | 无符号右移 |

**数组**

一维数组
1.是为数组对象在对象存储区中分配存储空间，2.是对数组对象进行初始化，3.是将新创建的数组对象与已声明的引用数组的变量（数组名）关联起来
a.直接指定初值   int []a = {1,2,3};
b.用关键字new创建数组对象 int []a = new int[5];  5个默认初值0

数据成员： length

*数组名之间的赋值*

```
int []a1={1,3,5,7,9};
int a3[]={2,1,3};
a3=a1;  //赋值结果a3指向a1指向的数组，a3先前指向的含有3个元素的数组由于没有指向而消失
```
*向成员方法传递数组元素*

```
class F{
int aa(int x,int y){
int z;
x=x+4;y=y+2;z=x*y;
return z;
}
}
public class test{
public static void main(String []args){
	int arr[]={6,8,9};
	F f = new F();
	int k =f.aa(arr[0],arr[1]);
}
}
```

数组元素作为成员方法的实参，程序中对形参的任何修改都不改变数组元素的值

*向成员方法传递数组名*
用数组名作为形参，则必须用具有相同数据类型的数组名作为实参
数组名作为实参时，是把实参数组对象的起始地址传递给形参数组名，两个数组共同引用同一对象，因此，在成员方法中对形参数组名指向的各元素值的修改，都会使实参数组名指向的各元素的值也发生同样的变化。

排序

冒泡：从前到后开始对相邻两个元素进行比较，如果后面的元素值小，则交换，否则不交换，第一趟排序中可以使得数组中值最达的元素移动下标为n-1的位置，


选择：拿第一个元素和其他元素比较，若大于其他位置元素则交换，否则继续，第一趟下来，元素最小的在下标为0的位置，则前面是有序区，后面是无序区。

对象数组

```
class Student{
private String name;
private char sex;
private double score;
}

Student st1 = new Student[3];
```

st1为st1[0]的地址
st1[0]为第一个对象的首地址
str1[0].name 为String对象的首地址
str1[0].sex  为字符变量
str1[0].score 为double数


二维数组

*声明二维数组时，系统只为二维数组的引用变量在内存的变量存储区分配存储空间，但并未创建具体的数组对象，所以这个值为null*

*数组名.length 得到的是数组的行数
数组名[i].length 得到的是该行的列数*


**字符串**

String 字符串常量
StringBuffer 字符串变量

String 
直接赋值  String str = "abcde";
构造函数  

| 构造方法                                  | 说明                                                     |
| ----------------------------------------- | -------------------------------------------------------- |
| String()                                  | 创建一个空字符串对象                                     |
| String(String value)                      | 用value字符串创建的新字符串对象                          |
| String(char value[])                      | value字符数组创建字符串对象                              |
| String(char value[],int offset,int count) | value字符数组中下标为offset开始，创建有count个字符的对象 |
| String(byte[] bytes,String charsetName)   | 通过指定的charset解码确定的byte数组，构造新String        |
| String(byte []b,int offset,int count)     | 通过默认字符集解码byte数组                               |
| String(StringBuffer b)                    |                                                          |

常用成员方法

| 成员方法                            | 功能                                     |
| ----------------------------------- | ---------------------------------------- |
| int length()                        |                                          |
| char charAt(int index)              |                                          |
| int indexOf(int ch)                 | 返回指定字符在此字符串中第一次出现的索引 |
| String subString(int begin,int end) | 返回下标begin到end-1的子串               |
| boolean equals(Object obj)          | 值的比较                                 |
| boolean equalsIgnoreCase(String s)  | 值的比较,不区分大小写                    |
| String toString()                   |                                          |
| int compareTo(String s)             | 按字典顺序比较两个字符串                 |

**main方法中的参数 (String []args)**

StringBuffer

| 构造                     | 说明                                       |
| ------------------------ | ------------------------------------------ |
| StringBuffer()           | 空字符串缓冲区，默认初始长度16字符         |
| StringBuffer(int length) | length创建指定长度的字符串缓冲区           |
| StringBuffer(String str) | 用指定字符串str创建，长度为str长度加16字符 |

成员函数

| 方法                                       | 说明                                           |
| ------------------------------------------ | ---------------------------------------------- |
| StringBuffer append(Object obj)            | 添加到字符串末尾                               |
| int length()                               |                                                |
| char charAt(int index)                     |                                                |
| void setcharAt(int index,char ch)          | 把下标index处字符设置为ch                      |
| StringBuffer insert(int offset,Object obj) | obj.toString()返回的字符串插入字符下标offset处 |





------------

*2019-04-11 11:51:46 星期四
萧逸小杨*