---
title: 编译原理（第六章 运行时存储空间的管理）
date: 2020-01-08 21:05:03
tags: [编译原理]
categories: [学习笔记]
---

 过程和函数叫过程；程序运行时过程的一次执行称为一次活动，所需的局部数据叫活动记录，过程的一次活动叫生存期

<!--more-->

#### 局部存储分配

名字----》存储单元   环境

存储单元----》值    状态

一个名字对应一个或多个存储单元，一个存储单元对应一个或多个名字

**活动记录**

|                |
| -------------- |
| 临时数据       |
| 局部数据       |
| 保存的机器状态 |
| 访问链         |
| 控制链         |
| 返回值         |
| 参数           |

**局部数据的布局**

字节对齐

char
long
char
double

64位   24
32位   20



char
char
long
double

64位 16
32位 16

一个过程声明的局部变量按它们声明时出现的次序，在活动记录中依次分配存储空间，这些局部数据的地址可以用相对于活动记录中某个位置的相对地址来表示。


**全局栈式存储分配**


|          |
| -------- |
| 代码     |
| 静态区   |
| 堆       |
| 空闲内存 |
| 栈       |



用树来描述进入和离开活动的次序，叫**活动树**

当前活跃的过程活动可以保存在一个栈中，叫**控制栈**

如果控制栈中的信息包含过程活动的活动记录，控制栈就成了活动记录栈，称为**运行栈**


**调用序列**

在过程调用时执行的分配活动记录，以及把信息填入其域中的代码称为过程调用序列，

在过程返回时执行的恢复机器状态，回收活动记录，以及让调用过程继续执行的代码称为过程返回序列，


寄存器top_sp指向栈顶活动记录的末端
另一个寄存器base_sp指向栈顶活动记录中控制链所在的位置，它作为访问栈顶活动记录中内容的基地址

**悬空引用**

引用某个已被回收的存储单元称为悬空引用

已被回收的存储单元的值是没有定义的，更糟糕的是，已被回收的单元可能随后被分配存储其他数据，悬空引用可能出现难以理解，不会被捕获的错误


```
int *dangle(){
	int j=20;
	return &j;   //返回局部变量的引用
}
main(){
	int *q;
	q=dangle();
}
```

**非局部名字的访问**

如果某个函数中对名字a有非局部引用，那么a必须作为外部变量，声明在所有函数的外面

声明在过程外面的变量都可以分配在静态区，它们的存储位置在编译时都可以确定，所以，过程体的非局部引用可以直接使用静态确定的地址，任何其他变量必定局部与栈顶的活动记录，可以通过base_sp指针来访问


**参数传递**


**值调用**

把形参当做所在过程的局部名看待，形参的存储单元在该过程的活动记录中
调用者计算实参，并把他的值放入形参的存储单元中

**引用调用**

调用者把实参存储单元的地址传给被调用者，被调用者对形参的任何访问就是读对应实参的访问

**换名调用**

把过程当做宏来对待，在调用点，用被调用过程的过程体来替换调用者的调用，这种称为宏展开和内联展开

被调用过程的局部名字与调用过程的名字保持区别，在宏展开前，被调用过程的局部名字都系统的被重新命名成可区别的名字。

为保持实参的完整性，实参可由括号包围