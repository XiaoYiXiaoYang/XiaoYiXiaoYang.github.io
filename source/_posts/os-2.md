---
title: 操作系统复习(进程)
date: 2019-12-22 19:19:14
tags: [操作系统]
categories: [学习笔记]
---

 作为资源分配和独立运行的基本单位

<!--more-->

**前趋图**

前趋图是一个有向无循环图，DAG，用于描述进程之间执行的前后关系。结点间的有向边则用于表示两个结点之间存在的前趋关系

**程序顺序执行的特征**

顺序性、封闭性、可再现性

**程序并发执行的特征**

间断性、失去封闭性、不可再现性

**进程**

进程是程序的一次执行。
进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 

进程是一个正在执行中的程序
进程是一个正在计算机上执行的程序实例
能分配给处理器并由处理器执行的实体
一个具有以下特征的活动单元：一组指令序列的执行、一个当前状态和相关的系统资源

**进程状态**

创建状态：申请一个空白PCB，向PCB写信息，分配运行时必须的资源，转入就绪状态

终止状态：将PCB清空，将PCB空间返还给系统

就绪状态：进程已经分配到除CPU外所有必要资源，只要得到CPU即可运行，自己排成就绪队列

阻塞状态：正在执行的进程由于发生某事件暂时无法继续执行时的状态

执行状态：进程已获得CPU正在执行的状态

挂起状态：进程处于静止状态（就绪挂起、阻塞挂起）

两态模型：运行<---->未运行

三态模型：就绪 <-----> 阻塞 <-----> 执行

五态模型：创建 <-----> 就绪 <-----> 阻塞 <-----> 执行 <-----> 终止

七态模型： 创建 <-----> 就绪 <-----> 就绪挂起 <-----> 阻塞 <-----> 阻塞挂起 <-----> 执行 <-----> 终止


| 状态 | 原因                                                         | 过程                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 创建 | 1.用户登录  2.作业调度 3.提供服务 4.应用请求                 | 1.申请空白PCB 2.为新进程分配其运行所需资源 3.初始化PCB 4.插入就绪队列 |
| 终止 | 1.正常结束 2.异常结束 3.外界干预                             | 1.根据终止进程标识符读取该进程的PCB 2.若该进程在执行则结束 3.若有子孙进程则终止他们 4.将终止的资源归还该父进程或系统 5.将PCB移出 |
| 阻塞 | 1.向系统请求资源失败 2.等待某种操作完成 3.新数据尚未到达 4.等待新任务的到达 | 1.调用阻塞原语block将自己阻塞 2.修改PCB状态 3.插入阻塞队列   |
| 唤醒 |                                                              | 1.调用唤醒原语block将自己唤醒 2.修改PCB状态 3.插入就绪队列   |
| 挂起 |                                                              | 1.调用挂起原语suspend将自己挂起 2.修改PCB状态                |
| 激活 |                                                              | 1.调用激活原语active将自己激活 2.修改PCB状态                 |


**进程描述**

- PCB

进程标识符
处理机状态
进程调度信息
进程控制信息

- 组织方式

线性
链接
索引

系统态(管态)：具有较高的特权，能执行一切执行，访问所有寄存器和存储区

用户态（目态）：具有较低特权的执行状态，仅能执行规定的指令，访问指定的寄存器和存储区


**进程同步**

临界资源：一段时间只能被一个进程访问的资源

临界区：访问临界资源的代码


- 同步机制准则

空闲让进
忙则等待
有限等待
让权等待

- 硬件同步机制

关中断

Test Set指令

Swap指令

- 信号量机制

整型信号量

记录型信号量

AND型信号量

信号量集

- 管程机制

管程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块

1.局部数据变量只能被管程访问，任何外部过程都不能访问，
2.一个进程通过调用管程的一个过程进入管程
3.在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程被挂起，以等待管程变为可用

- 经典问题

生产者-消费者
哲学家进餐
读者-写者


**进程通信**

共享存储区、消息传递、管道通信


**线程**

每个线程有

线程的执行状态(就绪、运行)
在未运行时保存的线程上下文
一个执行栈
用于每个线程局部变量的静态存储空间
对所属进程的内存和资源进行访问，并与该进程中其他线程共享这些资源


**处理机调度的层次**

高级调度：作业调度

低级调度：进程调度

中级调度：内存调度

**调度算法的目标**

1.资源利用率

2.公平性

3.平衡性

4.策略强制执行


**调度算法**

- 先来先服务

- 短作业优先

- 优先级调度(等待时间越长，优先级越高)

- 高响应比优先调度(优先权 = (等待时间+要求服务时间)/ 要求服务时间)

- 时间片轮转法(时间片略大于一次典型交互所需时间)

- 多级反馈队列(优先级+时间片)

**实时调度**(不讲)

- 最早截止时间优先

- 最低松弛度优先

- 优先级倒置


**死锁**

1.竞争资源

2.进程间推进顺序非法

- 产生死锁的必要条件

1.互斥条件

2.请求和保持条件(已经保持了一个资源，再请求另一个资源)

3.不可抢占条件(资源没有使用完之前不能被抢占)

4.循环等待条件(进程-资源循环链)

- 处理死锁方法

1.预防死锁

2.避免死锁

3.检测死锁

4.解除死锁

- 预防死锁

破坏“请求和保持”条件

**协议1：一次性申请其在整个运行过程中所需的全部资源**

**协议2：允许进程只获得运行初期所需的资源后，便开始运行，运行中再逐步释放已分配给自己的、且用完毕的资源，再请求新的资源**




破坏“不可抢占”条件

**当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请**



破坏“循环等待”条件

**对系统所有资源类型进行线性排序，并赋予不同的序号规定每个进程只能按序号递增的顺序请求资源**



- 避免死锁

银行家算法

- 检测死锁

资源分配图

用圆圈代表一个进程，用方框代表一类资源。

资源---->进程  进程已经分得了一个资源
进程--->资源  进程请求一个资源

死锁定理：S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。

- 解除死锁

剥夺资源

撤销进程







------------

2019-07-02 14:50:18 星期二

