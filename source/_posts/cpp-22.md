---
title: C++ Primer(第13章 拷贝控制)
date: 2019-12-15 17:18:28
tags: [C++ Primer]
categories: [学习笔记]
---



拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符

<!--more-->



#### 拷贝、赋值、销毁

**拷贝构造函数**

- 拷贝构造函数的第一个参数必须是引用类型
- 合成的拷贝构造函数对会将参数的成员逐个拷贝到正在创建的对象中去，对内置类型的成员则直接拷贝，对类类型的成员则使用拷贝构造函数拷贝



```
string s("123");  //直接初始化
string s2(s);    //直接初始化
string s3 = s;   //拷贝初始化
string s4 = "123";  //拷贝初始化
```

拷贝初始化发生的时机：

- 将一个对象作为实参传递给另一个非引用的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或者聚合类中的成员



**参数和返回值**

- 拷贝构造函数是用来初始化非引用类类型的参数

- 所以拷贝构造函数的参数必须是引用类型，否则永远无法调用成功



**拷贝赋值运算符**

重载赋值运算符

```
Foo &operator =(const Foo&);
```



合成拷贝赋值运算符

*它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员*



**析构函数**

调用时机

- 变量离开作用域时被销毁
- 当一个对象被销毁时其成员被销毁
- 容器被销毁时
- 对于动态分配的对象，当指向他的指针使用delete时
- 临时对象，在创建它的完整的表达式结束时



合成析构函数



**三/五法则**

三个基本操作控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符、析构函数

还可以定义一个移动构造函数和一个移动赋值运算符



**需要析构函数的类也需要拷贝和赋值操作**

**需要拷贝操作的类也需要赋值操作，反之亦然**



**阻止拷贝**

将其定义为删除的函数

```
Foo(Foo&); = delete;
Foo& operator = (Foo&) = delete;
```



**析构函数不能是删除的**

如果析构函数被删除，就无法销毁此类型的对象了







#### 对象移动



**右值引用**

必须绑定到右值的引用，我们通过&&而不是&来获得右值引用



**移动构造函数和移动赋值运算符**



移动构造函数的第一个参数是该类类型的一个引用，这个引用是一个右值引用

一旦资源完成移动，源对象必须不再指向被移动的资源--这些资源的所有权已经归属新创建的对象



```
Foo(Foo &&f)
{

}
```



**移动后源对象必须可销毁**

- 当编写一个移动操作时，必须确保移后源对象进入一个可析构的状态



**合成的移动操作**

- 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它们合成移动构造函数或移动赋值运算符

...未完待续















